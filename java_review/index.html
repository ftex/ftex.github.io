<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="j.c">
  
  
  
  
  <link rel="next" href="https://ftex.github.io/about/" />
  <link rel="canonical" href="https://ftex.github.io/java_review/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
            | ftex&#39;s blog
       
  </title>
  <meta name="title" content=" | ftex&#39;s blog">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/ftex.github.io\/"
    },
    "articleSection" : "",
    "name" : "",
    "headline" : "",
    "description" : "java总结 JCSprout\n多线程 文章 https:\/\/juejin.im\/post\/5b57b81af265da0f4b7a9ae5 https:\/\/blog.csdn.net\/SEU_Calvin\/article\/details\/52411531 http:\/\/ifeve.com\/15-java-faq\/ https:\/\/zhuanlan.zhihu.com\/p\/34678757 （讲解的比较详细） java内存模型 http:\/\/blog.csdn.net\/suifeng3051\/article\/details\/52611310 Java Memory Model(JMM)，定义了多线程之间共享变量的可见性和如何在需要的时候对共享变量进行同步。线程之间通讯分为共享内存和消息传递两种方式，java使用的是共享内存的方式。 从JVM角度来看，JMM就是决定一个线程对共享变量的写入何时对另一个线程可见，线程之间的共享变量存储在堆中的主内存(main memory)中，每个线程都在线程栈上有一个私有的本地内存(local memory)，本地内存中存储了该线程以读\/写共享变量的副本。 从硬件角度来看，我们的数据存储再内存中，负责计算的CPU每个核都有一组寄存器（也就是CPU的存储器），多个CPU缓存。处理速度：寄存器\x26gt;一级缓存\x26gt;二级缓存\x26gt;主内存，当CPU需要访问主内存中的数据的时候，会先读取一部分主内存数据到CPU缓存，再把CPU缓存的数据读取到寄存器。当CPU需要写入数据到主存时，同样会先flush寄存器到CPU缓存，再在某些节点把缓存数据flush到主存中。 通过上述两个角度我们可以看出对内存中数据的读取，我们需要解决数据的可见性和执行的顺序性，java提供了volatile和synchronized这两个关键字来解决这些问题。volatile关键字基于CPU内存屏障指令实现，保证一个线程对变量的写入可以对其他线程可见。synchronized代码块可以保证同一时刻只能有一个线程进入代码的竞争区，也能保证volatile的可见性，当线程退出代码块时，对变量的更新将会flush到主存中，不管这些变量是不是volatile类型的。   Thread方法的使用 线程的状态从创建到最终的消亡分为：new(创建)、runnable(就绪)、running(运行)、blocked(阻塞)、time waiting、waiting、dead(消亡)，thread的主要方法：  start()：开启一个新的线程执行用户定义的子任务（run()中执行的任务）,在这个过程中会为对应线程分配需要的资源； run()：执行具体任务的代码逻辑； sleep()：让线程睡眠，交出CPU，让CPU执行其他任务，但是不会释放当前线程持有的对象锁； yield()：让出当前线程的CPU使用权给拥有相同优先级的线程执行任务，和slee()不同的是不能控制具体的交出CPU的时间，和sleep()一样不会释放当前线程持有的对象锁； join()：join方法的作用是父线程等待子线程执行完成后再执行，换句话说就是将异步执行的线程合并为同步的线程。底层调用的是Object的wait()，wait()方法会让线程进入阻塞状态，并且释放占有的锁，并交出CPU执行权限， interrupt():使处于阻塞的线程抛出InterruptedException，以达到线程中断的效果，但是线程如果未阻塞而是正在运行中，则需要配合通过while(!isInterrupted() \x26amp;\x26amp; 业务条件限制 ){ doSomething();}的方式来中断正在运行的线程。 stop()：这是一个废弃的方法，它是一个不安全的方法。因为调用stop方法会直接终止run方法的调用，并且会抛出一个ThreadDeath错误，如果线程持有某个对象锁的话，会完全释放锁，导致对象状态不一致。所以stop方法基本是不会被用到的。 destroy()：destroy方法也是废弃的方法。基本不会被使用到。  synchronized原理  每个对象都存在着一个monitor与之关联，对象与其monitor之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个monitor被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，ObjectMonitor中有两个队列，_WaitSet和_EntryList，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入_EntryList集合，当线程获取到对象的monitor后进入_Owner区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。 当用来修饰同步代码块时，从字节码中可知同步语句块的实现使用的是monitorenter和monitorexit指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置和异常处理器结束的位置，并且为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理器，它可以处理所有异常，在捕获到异常后执行monitorexit指令。 当用来修饰方法时，通过字节码可以看出在方法的flags中多了ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法，JVM通过该ACC_SYNCHRONIZED访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用 锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。  偏向锁： 轻量级锁： 重量级锁：即监视器锁(monitor)，因为它是依赖于底层的操作系统的Mutex Lock来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。   java 线程池实现  构造函数参数：  corePoolSize(基本线程数)：初始化和在没有任务执行时线程池的大小，只有在工作队列满了的情况下才会创建超出这个数量的线程； maximumPoolSize(最大线程数)：可同时活动的线程数的上限； keepAliveTime(线程空闲时间)：如果某个线程的空闲时间超过存活时间，那么将被标记为可回收的，并且当线程池的当前大小超过了基本大小时，这个线程将被终止。 unit(时间单位) workQueue(任务队列) threadFactory(线程工厂) rejectedExecutionHandler(饱和策略)  可通过Executors提供的newCachedThreadPool、newFixedThreadPool、newScheduledThreadPool、newSingleThreadExecutor等静态方法来构建线程池，这些方法部分内部是使用new ThreadPoolExecutor()来构建的;  newFixedThreadPool：将线程池的基本大小和最大大小设置为参数中指定的值，而且创建的线程池不会超时; newCachedThreadPool：将线程池的最大大小设置为Integer.",
    "inLanguage" : "en-us",
    "author" : "j.c",
    "creator" : "j.c",
    "publisher": "j.c",
    "accountablePerson" : "j.c",
    "copyrightHolder" : "j.c",
    "copyrightYear" : "0001",
    "datePublished": "0001-01-01 00:00:00 \x2b0000 UTC",
    "dateModified" : "0001-01-01 00:00:00 \x2b0000 UTC",
    "url" : "https:\/\/ftex.github.io\/java_review\/",
    "wordCount" : "958",
    "keywords" : [  "ftex\x27s blog"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://ftex.github.io/">ftex&#39;s blog</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/post/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://ftex.github.io/">ftex&#39;s blog</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/post/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<div class="post-warp archive">
    <h2 class="post-title" style="text-align:right;padding-bottom:2em"></h2>
    <div class="post-content">
        

<h3 id="java总结">java总结</h3>

<p><a href="https://github.com/crossoverJie/JCSprout" rel="nofollow noreferrer" target="_blank">JCSprout</a></p>

<h3 id="多线程">多线程</h3>

<ul class="task-list">
<li><strong>文章</strong>

<ul class="task-list">
<li><label><input type="checkbox" checked disabled class="task-list-item"> <a href="https://juejin.im/post/5b57b81af265da0f4b7a9ae5" rel="nofollow noreferrer" target="_blank">https://juejin.im/post/5b57b81af265da0f4b7a9ae5</a></label></li>
<li><label><input type="checkbox" checked disabled class="task-list-item"> <a href="https://blog.csdn.net/SEU_Calvin/article/details/52411531" rel="nofollow noreferrer" target="_blank">https://blog.csdn.net/SEU_Calvin/article/details/52411531</a></label></li>
<li><label><input type="checkbox" checked disabled class="task-list-item"> <a href="http://ifeve.com/15-java-faq/" rel="nofollow noreferrer" target="_blank">http://ifeve.com/15-java-faq/</a></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="https://zhuanlan.zhihu.com/p/34678757" rel="nofollow noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/34678757</a>  （讲解的比较详细）</label></li>
<li><label><input type="checkbox" checked disabled class="task-list-item"> <strong>java内存模型</strong>

<ul class="task-list">
<li><label><input type="checkbox" checked disabled class="task-list-item"> <a href="http://blog.csdn.net/suifeng3051/article/details/52611310" rel="nofollow noreferrer" target="_blank">http://blog.csdn.net/suifeng3051/article/details/52611310</a></label></li>
<li>Java Memory Model(<strong>JMM</strong>)，定义了多线程之间共享变量的可见性和如何在需要的时候对共享变量进行同步。线程之间通讯分为<strong>共享内存</strong>和<strong>消息传递</strong>两种方式，java使用的是<strong>共享内存</strong>的方式。</li>
<li><strong>从JVM角度来看</strong>，JMM就是决定一个线程对共享变量的写入何时对另一个线程可见，线程之间的共享变量存储在堆中的主内存(main memory)中，每个线程都在线程栈上有一个私有的本地内存(local memory)，本地内存中存储了该线程以读/写共享变量的副本。</li>
<li><strong>从硬件角度来看</strong>，我们的数据存储再内存中，负责计算的CPU每个核都有一组寄存器（也就是CPU的存储器），多个CPU缓存。处理速度：<strong>寄存器&gt;一级缓存&gt;二级缓存&gt;主内存</strong>，当CPU需要访问主内存中的数据的时候，会先读取一部分主内存数据到CPU缓存，再把CPU缓存的数据读取到寄存器。当CPU需要写入数据到主存时，同样会先flush寄存器到CPU缓存，再在某些节点把缓存数据flush到主存中。</li>
<li>通过上述两个角度我们可以看出对内存中数据的读取，我们需要解决数据的可见性和执行的顺序性，java提供了<code>volatile</code>和<code>synchronized</code>这两个关键字来解决这些问题。<code>volatile</code>关键字基于CPU内存屏障指令实现，保证一个线程对变量的写入可以对其他线程可见。<code>synchronized</code>代码块可以保证同一时刻只能有一个线程进入代码的竞争区，也能保证<code>volatile</code>的可见性，当线程退出代码块时，对变量的更新将会flush到主存中，不管这些变量是不是volatile类型的。</li>
</ul></label></li>
</ul></li>
<li><label><input type="checkbox" checked disabled class="task-list-item"> <strong>Thread方法的使用</strong>
 线程的状态从创建到最终的消亡分为：new(创建)、runnable(就绪)、running(运行)、blocked(阻塞)、time waiting、waiting、dead(消亡)，thread的主要方法：

<ul>
<li>start()：开启一个新的线程执行用户定义的子任务（run()中执行的任务）,在这个过程中会为对应线程分配需要的资源；</li>
<li>run()：执行具体任务的代码逻辑；</li>
<li>sleep()：让线程睡眠，交出CPU，让CPU执行其他任务，但是不会释放当前线程持有的对象锁；</li>
<li>yield()：让出当前线程的CPU使用权给拥有相同优先级的线程执行任务，和slee()不同的是不能控制具体的交出CPU的时间，和sleep()一样不会释放当前线程持有的对象锁；</li>
<li>join()：join方法的作用是父线程等待子线程执行完成后再执行，换句话说就是将异步执行的线程合并为同步的线程。底层调用的是Object的wait()，wait()方法会让线程进入阻塞状态，并且释放占有的锁，并交出CPU执行权限，</li>
<li>interrupt():使处于阻塞的线程抛出InterruptedException，以达到线程中断的效果，但是线程如果未阻塞而是正在运行中，则需要配合通过while(!isInterrupted() &amp;&amp; 业务条件限制 ){ doSomething();}的方式来中断正在运行的线程。</li>
<li>stop()：这是一个废弃的方法，它是一个不安全的方法。因为调用stop方法会直接终止run方法的调用，并且会抛出一个ThreadDeath错误，如果线程持有某个对象锁的话，会完全释放锁，导致对象状态不一致。所以stop方法基本是不会被用到的。</li>
<li>destroy()：destroy方法也是废弃的方法。基本不会被使用到。</li>
</ul></label></li>
<li><label><input type="checkbox" checked disabled class="task-list-item"> <strong>synchronized原理</strong>

<ul>
<li>每个对象都存在着一个<code>monitor</code>与之关联，对象与其<code>monitor</code>之间的关系有存在多种实现方式，如<code>monitor</code>可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个<code>monitor</code>被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，<code>monitor</code>是由<code>ObjectMonitor</code>实现的，<code>ObjectMonitor</code>中有两个队列，<code>_WaitSet</code>和<code>_EntryList</code>，用来保存<code>ObjectWaiter对象</code>列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，<code>_owner</code>指向持有<code>ObjectMonitor对象</code>的线程，当多个线程同时访问一段同步代码时，首先会进入<code>_EntryList</code>集合，当线程获取到对象的<code>monitor</code>后进入<code>_Owner区域</code>并把<code>monitor</code>中的<code>owner变量</code>设置为当前线程同时<code>monitor</code>中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的<code>monitor</code>，<code>owner变量</code>恢复为null，count自减1，同时该线程进入<code>WaitSet集合</code>中等待被唤醒。若当前线程执行完毕也将释放<code>monitor(锁)</code>并复位变量的值，以便其他线程进入获取<code>monitor(锁)</code>。</li>
<li><strong>当用来修饰同步代码块时</strong>，从字节码中可知同步语句块的实现使用的是<code>monitorenter</code>和<code>monitorexit指令</code>，其中<code>monitorenter指令</code>指向同步代码块的开始位置，<code>monitorexit指令</code>则指明同步代码块的结束位置和异常处理器结束的位置，并且为了保证在方法异常完成时<code>monitorenter</code>和<code>monitorexit</code>指令依然可以正确配对执行，编译器会自动产生一个异常处理器，它可以处理所有异常，在捕获到异常后执行<code>monitorexit</code>指令。</li>
<li><strong>当用来修饰方法时</strong>，通过字节码可以看出在方法的flags中多了<code>ACC_SYNCHRONIZED</code>标识，该标识指明了该方法是一个同步方法，JVM通过该ACC_SYNCHRONIZED访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用</li>
<li>锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。

<ul>
<li><strong>偏向锁</strong>：</li>
<li><strong>轻量级锁</strong>：</li>
<li><strong>重量级锁</strong>：即监视器锁(monitor)，因为它是依赖于底层的操作系统的<code>Mutex Lock</code>来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。</li>
</ul></li>
</ul></label></li>
<li><label><input type="checkbox" checked disabled class="task-list-item"> <strong>java 线程池实现</strong>

<ul>
<li><strong>构造函数参数</strong>：

<ul>
<li>corePoolSize(基本线程数)：初始化和在没有任务执行时线程池的大小，只有在工作队列满了的情况下才会创建超出这个数量的线程；</li>
<li>maximumPoolSize(最大线程数)：可同时活动的线程数的上限；</li>
<li>keepAliveTime(线程空闲时间)：如果某个线程的空闲时间超过存活时间，那么将被标记为可回收的，并且当线程池的当前大小超过了基本大小时，这个线程将被终止。</li>
<li>unit(时间单位)</li>
<li>workQueue(任务队列)</li>
<li>threadFactory(线程工厂)</li>
<li>rejectedExecutionHandler(饱和策略)</li>
</ul></li>
<li>可通过Executors提供的newCachedThreadPool、newFixedThreadPool、newScheduledThreadPool、newSingleThreadExecutor等静态方法来构建线程池，这些方法部分内部是使用new ThreadPoolExecutor()来构建的;

<ul>
<li>newFixedThreadPool：将线程池的基本大小和最大大小设置为参数中指定的值，而且创建的线程池不会超时;</li>
<li>newCachedThreadPool：将线程池的最大大小设置为Integer.MAX_VALUE，而将基本大小设置为0，并将超时设置为1分钟，这种方法创建出来的线程池可以被无限扩展，并且当需求降低时会自动收缩，禁止使用此方法，避免线程池大小超出控制范围;</li>
<li>newScheduledThreadPool：</li>
</ul></li>
<li>任务队列

<ul>
<li>提供一个BlockingQueue来保存等待执行的任务。基本的任务排队方式有三种：无界队列、有界队列和同步移交。</li>
<li>有界队列可避免资源耗尽，但是如果队列被填满则需要使用饱和策略来解决这个问题；队列大小和线程池大小必须一起调节，如果线程池较小而队列较大，那么有助于减少内存使用量，降低CPU使用率，同时还可以减少上下文切换，但会限制吞吐量。</li>
<li>无界队列适用于newFixedThreadPool、newSingleThreadExecutor的场景。</li>
<li>同步移交：对于非常大或无界的线程池或当线程池可以拒绝任务时，如newCachedThreadPool，可使用SynchronousQueue来避免任务排队，直接将任务从生产者移交给工作者线程。它不是一个真正的队列，而是一种线程之间进行移交的机制。要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接受这个元素。</li>
<li>有界队列：ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue</li>
</ul></li>
<li><strong>饱和策略</strong>

<ul>
<li>AbortPolicy：默认策略，会抛出未检查的RejectExecutionException。调用方可捕获这个异常，再编写对应的处理代码</li>
<li>DiscardPolicy：抛弃当前处理的任务</li>
<li>DiscardOldestPolicy：抛弃队列中最前面的一个任务，然后尝试重新提交当前任务</li>
<li>CallerRunsPolicy：将任务回退到调用者，从而降低新任务的流量。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了execute的线程中执行该任务。由于执行任务需要一定的时间，因此主线程至少在一段时间内不能提交任务，从而使工作者线程有时间来处理完正在执行的任务。在这个期间，主线程不会调用accept，因此到达的请求将被保存在TCP层的队列中而不是在应用程序队列中。如果持续过载，那么TCP层将被最终发现他的请求队列被填满，因此同样会开始抛弃请求。这种逐渐向外蔓延的过载情况会让服务器在高负载的情况下实现一种平缓的性能降低。</li>
</ul></li>
<li><strong>执行过程</strong>：</li>
</ul></label></li>
<li><label><input type="checkbox" checked disabled class="task-list-item"> <strong>什么是守护线程，守护线程(Daemon Thread)和非守护线程(User Thread)的区别以及用法</strong>
 <br/>守护线程可以在new Thread()后，通过thread.setDaemon(true)设置，这个方法必须在start()之前设置，不然会报错。比较常见的守护线程就是GC线程，当虚拟机退出时会等待非守护线程关闭，而不会等待守护线程关闭才退出。一般用户线程是执行日常工作的，而守护线程用来给其他用户线程提供辅助服务的。</label></li>
<li><label><input type="checkbox" checked disabled class="task-list-item"> <strong>synchronized和volatile的作用</strong>

<ul class="task-list">
<li>1. volatile关键字的作用
<br/> 仅能保证可见性和有序性（不保证原子性），如果一个共享变量被volatile关键字修饰，那么如果一个线程修改了这个共享变量后，其他线程是立马可知的。为什么是这样的呢？比如，线程A修改了自己的共享变量副本，这时如果该共享变量没有被volatile修饰，那么本次修改不一定会马上将修改结果刷新到主存中，如果此时B去主存中读取共享变量的值，那么这个值就是没有被A修改之前的值。如果该共享变量被volatile修饰了，那么本次修改结果会强制立刻刷新到主存中，如果此时B去主存中读取共享变量的值，那么这个值就是被A修改之后的值了。
volatile能禁止指令重新排序，JMM会在写入这个字段后插入一个Write-Barrier指令，并在读取这个字段之前插入一个Read-Barrier指令，这保证了一个线程写入变量内容后，任何线程访问该变量时都会拿到最新值。在指令重排序优化时，在volatile变量之前的指令不能在volatile之后执行，在volatile之后的指令也不能在volatile之前执行，所以它保证了有序性。</li>
<li>2. synchronized关键字的作用
<br/> synchronized提供了同步锁的概念，它阻止了其他线程获取当前对象的监控锁，保证了synchronized修饰的代码段可以防止被多个线程同时执行，必须一个线程把synchronized修饰的代码段都执行完毕了，其他的线程才能开始执行这段代码。synchronized保证了在同一时刻，只能有一个线程执行同步代码块，所以执行同步代码块的时候相当于是单线程操作了，那么线程的可见性、原子性、有序性（线程之间的执行顺序）它都能保证了。synchronized还会创建一个内存屏障，内存屏障指令保证了所有CPU操作结果都会直接刷到主存中，从而保证了操作的内存可见性，同时也使得先获得这个锁的线程的所有操作，都happens-before于随后获得这个锁的线程的操作。</li>
<li>3. volatile关键字和synchronized关键字的区别

<ul>
<li>volatile只能作用于变量，使用范围较小。synchronized可以用在变量、方法、类、同步代码块等，使用范围比较广。</li>
<li>volatile只能保证可见性和有序性，不能保证原子性。而可见性、有序性、原子性synchronized都可以包证。</li>
<li>volatile不会造成线程阻塞。synchronized可能会造成线程阻塞。</li>
<li>volatile修饰的变量不会被编译器优化，synchronized会被编译器优化。</li>
</ul></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="https://blog.csdn.net/chenssy/article/details/54883355" rel="nofollow noreferrer" target="_blank">https://blog.csdn.net/chenssy/article/details/54883355</a></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="https://blog.csdn.net/javazejian/article/details/72828483" rel="nofollow noreferrer" target="_blank">https://blog.csdn.net/javazejian/article/details/72828483</a></label></li>
</ul></label></li>
</ul>

<h3 id="jvm">JVM</h3>

<ul class="task-list">
<li>文章：

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="https://blog.csdn.net/jisuanjiguoba/article/details/80176223" rel="nofollow noreferrer" target="_blank">https://blog.csdn.net/jisuanjiguoba/article/details/80176223</a></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="http://www.cnblogs.com/zhguang/p/Java-JVM-GC.html" rel="nofollow noreferrer" target="_blank">http://www.cnblogs.com/zhguang/p/Java-JVM-GC.html</a></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="https://blog.csdn.net/aoxida/article/details/45061571" rel="nofollow noreferrer" target="_blank">https://blog.csdn.net/aoxida/article/details/45061571</a></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="https://blog.csdn.net/zp357252539/article/details/52197708" rel="nofollow noreferrer" target="_blank">https://blog.csdn.net/zp357252539/article/details/52197708</a></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> java内存管理参考资料：

<ul class="task-list">
<li><a href="http://www.importnew.com/21463.html" rel="nofollow noreferrer" target="_blank">http://www.importnew.com/21463.html</a></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="http://www.cnblogs.com/gw811/archive/2012/10/18/2730117.html" rel="nofollow noreferrer" target="_blank">java内存管理</a></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="http://blog.csdn.net/tutngfei1129287460/article/details/7383480" rel="nofollow noreferrer" target="_blank">java内存管理机制</a></label></li>
</ul></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> java堆和栈

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="http://blog.csdn.net/emira_j/article/details/51232611" rel="nofollow noreferrer" target="_blank">http://blog.csdn.net/emira_j/article/details/51232611</a></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="http://www.cnblogs.com/whgw/archive/2011/09/29/2194997.html" rel="nofollow noreferrer" target="_blank">http://www.cnblogs.com/whgw/archive/2011/09/29/2194997.html</a></label></li>
</ul></label></li>
</ul></li>
<li><label><input type="checkbox" disabled class="task-list-item"> 垃圾回收机制

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="https://albk.tech/JVM%E7%AF%87-%E4%B9%8B-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.html" rel="nofollow noreferrer" target="_blank">垃圾收集器</a></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="https://matt33.com/2018/07/28/jvm-cms/" rel="nofollow noreferrer" target="_blank">ParNew 和 CMS 日志分析</a></label></li>
</ul></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> 逃逸分析</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> 简单介绍下JVM各种参数及调优</label></li>
</ul>

<h3 id="数据结构和基础知识">数据结构和基础知识</h3>

<ul class="task-list">
<li><label><input type="checkbox" checked disabled class="task-list-item"> <strong>StringBuilder 和 StringBuffer 的区别是什么？什么时候该用 + 来拼接字符串？什么时候该用StringBuilder ？什么时候该用 StringBuffer ？</strong>
<br/> 这三个类之间的区别主要是在两个方面，即运行速度和线程安全这两方面。

<ul>
<li>首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String。String最慢的原因：String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。</li>
<li>再来说线程安全，在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的
如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。一般单线程操作中，可以在一行代码中拼接完的字符串操作，都用 + 操作符就可以了，因为 + 操作符默认会使用 StringBuilder 来拼接；如果单线程操作中，拼接字符串需要使用循环，那么直接使用 StringBuilder 比较合适；如果在拼接字符串的操作处于多线程环境中，需要使用 StringBuffer 来操作。

<ul>
<li>String：适用于少量的字符串操作的情况；</li>
<li>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况；</li>
<li>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况；
<a href="https://segmentfault.com/a/1190000007099818" rel="nofollow noreferrer" target="_blank">https://segmentfault.com/a/1190000007099818</a>
<a href="https://www.cnblogs.com/shanheyongmu/p/9583381.html" rel="nofollow noreferrer" target="_blank">https://www.cnblogs.com/shanheyongmu/p/9583381.html</a></li>
</ul></li>
</ul></label></li>
<li><label><input type="checkbox" checked disabled class="task-list-item"> <strong>如果碰到多重循环需要跳出该如何操作？</strong>
  <br/>可以使用循环标签，即在循环关键字前加上一个标签名及冒号，在需要跳出的地方（ break ${labelName} 或 continue ${labelName} ）进行跳出。</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>HashMap的实现原理</strong> <a href="https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" rel="nofollow noreferrer" target="_blank">链接</a><br />

<ul>
<li>1. 利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</li>
<li>2. 存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中</li>
<li>3. 获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</li>
<li>4. 理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。
<img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/d669d29c.png" alt="" /></li>
</ul></label></li>
</ul>

<pre><code class="language-java">public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
 }
static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}
</code></pre>

<ul class="task-list">
<li><label><input type="checkbox" checked disabled class="task-list-item"> <strong>HashMap的一些问题</strong>

<ul>
<li>为什么链表长度为8时会变更链表为红黑树，当红黑树节点缩减为6时又自动变更成链表结构

<ul>
<li>因为链表的时间复杂度是O(n)，红黑树的时间复杂度是O(logn)，红黑树的空间复杂度是链表的2倍，选择数据结构时，需要权衡时间空间复杂度。官方文档中给出一个概率：hashmap中一个链表的长度为8的概率是0.00000006，几乎不可能出现的事件，而且长度为8的链表的时间复杂度要比红黑树高，小于8时两者的时间复杂度基本相同，所以长度为8时变更链表为红黑树。从红黑树变更成链表的长度是6而不是7的原因是因为避免链表红黑树频繁切换。详见<a href="https://www.javazhiyin.com/34651.html" rel="nofollow noreferrer" target="_blank">链接</a> ,<a href="https://albenw.github.io/posts/df45eaf1/" rel="nofollow noreferrer" target="_blank">链接2</a></li>
</ul></li>
<li>在高并发场景中为什么会出现死循环
<br/>在数组长度不够的情况下，需要申请一个更大内存的数组，分配元素的时候如果存在链表，hashmap中的链表是将元素放置在首节点的，那么重新分配的时候会将链表倒序排列，在并发场景的时候很容易让链表出现环的现象，这样会造成死循环。(关键点：table中的链表元素是线程共享的，会出现entry2.next = entry2的情况)<a href="https://juejin.im/post/5a224e1551882535c56cb940" rel="nofollow noreferrer" target="_blank">链接</a> 、<a href="https://juejin.im/post/5a66a08d5188253dc3321da0" rel="nofollow noreferrer" target="_blank">链接</a>、<a href="https://www.jianshu.com/p/c15f7c180375" rel="nofollow noreferrer" target="_blank">漫画</a></li>
<li>JDK1.8对HashMap做了哪些性能优化

<ul>
<li>从数组+链表改成了数组+链表和红黑树；</li>
<li>优化了高位运算的hash算法：h^(h&gt;&gt;&gt;16);</li>
<li>扩容后，元素要么是在原位置，要么是在原位置再移动2次幂的位置，且链表使用尾插法，避免出现死循环；</li>
</ul></li>
<li>为什么HashMap底层数组的长度总是2的n次方？

<ul>
<li>这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</li>
</ul></li>
<li>和ConcurrentHashMap的区别</li>
<li>HashMap与HashTable的区别？

<ul>
<li>1. HashMap是非线程安全的，HashTable是线程安全的。</li>
<li>2. HashMap的键和值都允许有null值存在，而HashTable则不行。 3、因为线程安全的问题，HashMap效率比HashTable的要高。</li>
</ul></li>
</ul></label></li>
<li><label><input type="checkbox" checked disabled class="task-list-item"> <strong>进程和线程的区别与联系？</strong>

<ul>
<li>进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1–n个线程。
线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。</li>
<li>线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。</li>
</ul></label></li>
<li><label><input type="checkbox" checked disabled class="task-list-item"> <strong>在java中要想实现多线程，有几种方法？</strong>

<ul>
<li>继续Thread类、实现Runable接口或实现Callable接口。</li>
</ul></label></li>
<li><label><input type="checkbox" checked disabled class="task-list-item"> <strong>switch能否用string做参数？</strong>

<ul>
<li>在 Java 7 之前, switch 只能支持byte,short,char,int 或者其对应的封装类以及 Enum 类型。在Java 7中,String 支持被加上了。
Java7编译器进行了优化，String比较的原理是先使用hashCode判断，再通过equals判断值是否相等。</li>
</ul></label></li>
<li><label><input type="checkbox" checked disabled class="task-list-item"> <strong>Object有哪些公用方法？</strong>

<ul>
<li>1. 方法equals测试的是两个对象是否相等</li>
<li>2. 方法clone进行对象拷贝</li>
<li>3. 方法getClass返回和当前对象相关的Class对象</li>
<li>4. 方法notify,notifyAll,wait都是用来对给定对象进行线程同步的</li>
</ul></label></li>
<li><label><input type="checkbox" checked disabled class="task-list-item"> <strong>Java的四种引用以及应用场景？</strong>

<ul>
<li><strong>强引用</strong>：如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。</li>
<li><strong>软引用(SoftReference)</strong>：在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。</li>
<li><strong>弱引用(WeakReference)</strong>：具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象。</li>
<li><strong>虚引用(PhantomReference)</strong>：顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。</li>
</ul></label></li>
<li><label><input type="checkbox" checked disabled class="task-list-item"> <strong>抽象类和接口的区别？</strong>

<ul>
<li>一个类只能继承单个类，但是可以实现多个接口</li>
<li>抽象类中可以有构造方法，接口中不能有构造方法</li>
<li>抽象类中的所有方法并不一定要是抽象的，你可以选择在抽象类中实现一些基本的方法。而接口要求所有的方法都必须是抽象的</li>
<li>抽象类中可以包含静态方法，接口中不可以</li>
<li>抽象类中可以有普通成员变量，接口中不可以</li>
</ul></label></li>
<li><label><input type="checkbox" checked disabled class="task-list-item"> <strong>ThreadLocal</strong>

<ul>
<li>每个Thread都存储了一个ThreadLocalMap，当ThreadLocal.get()的时候实际上是通过System.currentThread().threadLocals.getEntry(this)来获取对应值的，其中的this是ThreadLocal的实例。ThreadLocalMap中的entry继承自WeakReference(弱引用)，当entry的key，也就是threadlocal使用完成的时候，系统就会回收这部分内存。</li>
<li>用于保存某个线程共享变量：对于同一个static ThreadLocal，不同线程只能从中get，set，remove自己的变量，而不会影响其他线程的变量。</li>
</ul></label></li>
<li><label><input type="checkbox" checked disabled class="task-list-item"> <strong>ConncurrentHashMap的实现</strong> <a href="https://www.jianshu.com/p/d10256f0ebea" rel="nofollow noreferrer" target="_blank">link1</a>   <a href="http://www.jasongj.com/java/concurrenthashmap/" rel="nofollow noreferrer" target="_blank">link2</a>

<ul>
<li>1.7使用的是分段锁机制，1.8使用的是和hashmap类似的数据结构：数组+链表和红黑树，在数据插入的时候如果当前node没有值则使用cas插入元素，如果有值则使用synchronized锁定链表头结点，再插入元素，链表长度超过8则转化为红黑树。</li>
</ul></label></li>
<li><label><input type="checkbox" checked disabled class="task-list-item"> <strong>ConcurrentHashMap的问题</strong>

<ul>
<li>ConcurrentHashMap的锁是如何加的？是不是分段越多越好?

<ul>
<li>不是，锁分段是和hardware thread数量相关的，也可以认为是和系统最大cpu并发数相关的。1.8不再使用锁分段技术，而是使用数组+链表或红黑树的方式实现。</li>
</ul></li>
<li>为什么ConcurrentHashMap中的链表转红黑树的阈值是8

<ul>
<li>和HashMap的答案一样，见上文。</li>
</ul></li>
<li>ConcurrenhashMap求size是如何加锁的，如果刚求完一段后这段发生了变化该如何处理

<ul>
<li>求size()最好的情况当然是把所有元素全部锁住，不允许任何变更，但为更好支持并发操作，ConcurrentHashMap会在不上锁的前提逐个Segment计算3次size，如果某相邻两次计算获取的所有Segment的更新次数（每个Segment都与HashMap一样通过modCount跟踪自己的修改次数，Segment每修改一次其modCount加一）相等，说明这两次计算过程中无更新操作，则这两次计算出的总size相等，可直接作为最终结果返回。如果这三次计算过程中Map有更新，则对所有Segment加锁重新计算Size。</li>
</ul></li>
</ul></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>并发队列ConcurrentLinkedQueue和阻塞队列LinkedBlockingQueue用法</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>J.U.C下列类的实现，AQS</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>读写锁</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>可重入的读写锁，可重入是如何实现的？</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>List，Map，Set接口，Collection接口差异</strong>

<ul>
<li>List,Set都是继承自Collection接口，Map则不是；</li>
<li>List特点：元素有放入顺序，元素可重复 ，Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。）</li>
<li>Set和List对比：

<ul>
<li>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。</li>
<li>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。</li>
</ul></li>
<li>Map适合储存键值对的数据；</li>
<li>线程安全集合类与非线程安全集合类；

<ul>
<li>LinkedList、ArrayList、HashSet是非线程安全的，Vector是线程安全的;</li>
<li>HashMap是非线程安全的，HashTable是线程安全的;</li>
</ul></li>
</ul></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>java序列化的作用和原理</strong>

<ul>
<li>Java序列化算法透析

<ul>
<li>Serialization（序列化）是一种将对象以一连串的字节描述的过程；反序列化deserialization是一种将这些字节重建成一个对象的过程。Java序列化API提供一种处理对象序列化的标准机制。在这里你能学到如何序列化一个对象，什么时候需要序列化以及Java序列化的算法，我们用一个实例来示范序列化以后的字节是如何描述一个对象的信息的。</li>
</ul></li>
<li>序列化的必要性

<ul>
<li>Java中，一切都是对象，在分布式环境中经常需要将Object从这一端网络或设备传递到另一端。这就需要有一种可以在两端传输数据的协议。Java序列化机制就是为了解决这个问题而产生。</li>
</ul></li>
<li>如何序列化一个对象</li>
<li>一个对象能够序列化的前提是实现Serializable接口，Serializable接口没有方法，更像是个标记。有了这个标记的Class就能被序列化机制处理。</li>
<li>为什么要用序列化</li>
<li>是因为在分布式的系统中有时候我们需要对象的传递，但是对象没有用中间件之类的配置，所以现在怎么把对象传递过去呢，我们能想到的就是把对象转成成字节存储到一个文件中，其中这个字节中既包括对象，也包括对象中存储的数据，也就是对象实例，当用的时候，在从这个文件中把存到硬盘中的字节流文件转成成对象。在这其中把对象和对象实例转化成字节流并存储到字节流文件中的过程就叫序列化，而从字节流文件中读取文件的过程就叫做反序列化。</li>
</ul></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>重写equals方法的时候为什么要重写hashcode方法？</strong>

<ul>
<li>如果申明一个对象作为map的key，那么map会比较key的hashCode()，和equals()方法 来确定是否存在这个key。2.如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用hashCode 方法都必须生成相同的整数结果。</li>
</ul></label></li>
</ul>

<pre><code class="language-java"> do {
     if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e;
  } while ((e = e.next) != null);
</code></pre>

<h3 id="分布式">分布式</h3>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> 分布式事务、治理、一致性</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> 服务限流、熔断</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> 领域驱动设计的思想，只需要懂</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> 分布式事务 二阶段提交</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> 学习资料

<ul>
<li>Google 的入门三篇（GFS / Big Table / Map Reduce）</li>
<li><a href="https://www.zhihu.com/question/29597104" rel="nofollow noreferrer" target="_blank">https://www.zhihu.com/question/29597104</a></li>
<li><a href="https://github.com/overnote/architecture/" rel="nofollow noreferrer" target="_blank">https://github.com/overnote/architecture/</a></li>
</ul></label></li>
</ul>

<h3 id="spring">spring</h3>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>1.Spring的注入bean的方式</strong></label></li>
<li><label><input type="checkbox" checked disabled class="task-list-item"> <strong>2.SpringMVC运行原理？</strong>

<ul>
<li>1. 客户端请求提交到DispatcherServlet；</li>
<li>2. 由DispatcherServlet控制器查询HandlerMapping，找到并分发到指定的Controller中；</li>
<li>3. Controller调用业务逻辑处理后，返回ModelAndView；</li>
<li>4. DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图；</li>
<li>5. 视图负责将结果显示到客户端。</li>
</ul></label></li>
<li><label><input type="checkbox" checked disabled class="task-list-item"> <strong>4.Spring Bean的作用域？</strong>

<ul>
<li>Singleton：Spring IOC容器中只有一个共享的Bean实例，一般都是Singleton作用域。</li>
<li>Prototype：每一个请求，会产生一个新的Bean实例。</li>
<li>Request：每一次http请求会产生一个新的Bean实例。</li>
</ul></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>Spring中 Bean生命周期</strong>
<br/> Spring IOC容器可以管理Bean的生命周期，允许在Bean生命周期的特定点执行定制的任务。
Spring IOC容器对Bean的生命周期进行管理的过程如下：

<ul>
<li>1. 通过构造器或工厂方法创建Bean实例</li>
<li>2. 为Bean的属性设置值和对其它Bean的引用</li>
<li>3. 调用Bean的初始化方法</li>
<li>4. Bean可以使用了</li>
<li>5. 当容器关闭时，调用Bean的销毁方法</li>
<li>6. 在 Bean 的声明里设置 init-method 和 destroy-method 属性, 为 Bean 指定初始化和销毁方法。</li>
</ul></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>6.Spring AOP</strong>

<ul>
<li><a href="https://blog.csdn.net/luanlouis/article/details/51155821" rel="nofollow noreferrer" target="_blank">AOP实现原理</a>、<a href="https://blog.csdn.net/luanlouis/article/details/51095702" rel="nofollow noreferrer" target="_blank">AOP设计基本原理</a></li>
<li>JDK动态代理：仅可以通过接口代理，代理类需要实现InvocationHandler接口，实现invoke方法，在这个方法中编写代理内容，再通过Proxy.newProxyInstance()生成对应实例调用对应方法。</li>
<li>Cglib：通过为目标类动态生成一个子类，通过在子类中织入相应逻辑来达到织入代理逻辑的目的。</li>
<li>AspectJ:静态织入，它有专门的编译器，在编译期间将Advice以字节码的形式织入到class文件中。</li>
<li>Spring AOP</li>
<li>切面（Aspect）：其实就是共有功能的实现。如日志切面、权限切面、事务切面等。在实际应用中通常是一个存放共有功能实现的普通Java类，之所以能被AOP容器识别成切面，是在配置中指定的。</li>
<li>通知（Advice）：是切面的具体实现。以目标方法为参照点，根据放置的地方不同，可分为前置通知（Before）、后置通知（AfterReturning）、异常通知（AfterThrowing）、最终通知（After）与环绕通知（Around）5种。在实际应用中通常是切面类中的一个方法，具体属于哪类通知，同样是在配置中指定的。</li>
<li>连接点（Joinpoint）：就是程序在运行过程中能够插入切面的地点。例如，方法调用、异常抛出或字段修改等，但Spring只支持方法级的连接点。</li>
<li>切入点（Pointcut）：用于定义通知应该切入到哪些连接点上。不同的通知通常需要切入到不同的连接点上，这种精准的匹配是由切入点的正则表达式来定义的。</li>
<li>目标对象（Target）：就是那些即将切入切面的对象，也就是那些被通知的对象。这些对象中已经只剩下干干净净的核心业务逻辑代码了，所有的共有功能代码等待AOP容器的切入。</li>
<li>代理对象（Proxy）：将通知应用到目标对象之后被动态创建的对象。可以简单地理解为，代理对象的功能等于目标对象的核心业务逻辑功能加上共有功能。代理对象对于使用者而言是透明的，是程序运行过程中的产物。</li>
<li>织入（Weaving）：将切面应用到目标对象从而创建一个新的代理对象的过程。这个过程可以发生在编译期、类装载期及运行期，当然不同的发生点有着不同的前提条件。譬如发生在编译期的话，就要求有一个支持这种AOP实现的特殊编译器；发生在类装载期，就要求有一个支持AOP实现的特殊类装载器；只有发生在运行期，则可直接通过Java语言的反射机制与动态代理机制来动态实现。</li>
</ul></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>spring事务的实现</strong>
<br/> 可以进一步了解下事务的配置，例如7中事务传播行为随机选择一个作介绍</label></li>
<li><label><input type="checkbox" checked disabled class="task-list-item"> <strong>IOC实现机制</strong>
<br/>Spring支持三种依赖注入方式，分别是属性（Setter方法）注入，构造注入和接口注入。通过DI（依赖注入）实现，而DI的含义是将依赖关系注入到对应Bean中，实现原理是在spring会先将申明成Bean的实例放入自己的map中，在加载Bean的时候检查对应Bean的名称和类型，如果符合则通过反射注入到对应Bean中。</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>ApplicationContext 和 BeanFactory 的区别？</strong>
<br/> 创建 Bean 对象的时机不同：

<ul>
<li>BeanFactory 采取延迟加载，第一次调用 getBean() 方法时才会初始化 Bean。</li>
<li>ApplicationContext 是加载完 applicationContext.xml 时，就创建具体的 Bean 对象的实例。（只对 BeanDefition 中描述为是单例的 bean，才进行饿汉式加载）</li>
</ul></label></li>
</ul>

<h3 id="数据库">数据库</h3>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>读写分离何时强制要读主库，读哪个从库是通过什么方式决定的，从库的同步mysql用的什么方式；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>主从复制；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>mysql的binlog</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>mysql的存储引擎；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>mysql引擎区别；</strong>

<ul>
<li>1. InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；<br /></li>
<li>2. InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；<br /></li>
<li>3. InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li>
<li>4. InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；<br /></li>
<li>5. Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</li>
<li>6. innodb是行级锁，myisam是表级锁;</li>
</ul></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>innodb对一行数据的读会加锁吗？不加锁，读实际读的是副本</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>mysql的默认隔离级别，其他隔离级别；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>求表的size，或做数据统计可用什么存储引擎；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>读多写少可用什么引擎；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>假如要统计多个表应该用什么引擎；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>select xx from xx where xx and xx order by xx limit xx； 如何优化这个（看explain）；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>左连接和右连接</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>sql语句各种条件的执行顺序，如select， where， order by， group by</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>mysql的行级锁加在哪个位置；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>行锁、表锁、列锁</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>乐观锁、悲观锁</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>mysql其他的性能优化方式；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>mysql是如何实现事务的；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>事务隔离级别；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>select、update</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>简单说一说drop、delete与truncate的区别？</strong>
delete和truncate只删除表的数据不删除表的结构
速度,一般来说: drop&gt; truncate &gt;delete 
delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效; 如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>索引是什么？什么作用？优缺点？</strong>
索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构。
普通索引、唯一索引、主键索引、全文索引。</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>数据库事务是什么？</strong>
事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。
ACID：即原子性、一致性、隔离线和持久性。</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>HBase和mysql的区别。</strong></label></li>
</ul>

<pre><code class="language-text">HBase基于列存储，查询中的选中规则是通过列来定义，因此整个数据库是自动索引化的。HBase无需考虑分库、分表，它可以对存储的数据自动切分数据，并支持高并发读写操作，使得海量数据存储自动具有更强的扩展性。但是HBase不包含事务，没有表与表之间关联查询，
mysql基于行存储，mysql的innodb引擎带事务控制，表之间的join比较方便；伸缩性比较差。
</code></pre>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>mysql如何自己实现读写分离？</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>cobar, Amoeba原理</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>如何在应用层实现mysql读写分离？</strong></label></li>
</ul>

<pre><code class="language-text"> 这个就是平时用到的，所以说的比较详细：
  总的来说，在进入Service之前，使用AOP来做出判断，是使用写库还是读库，判断依据可以根据方法名判断，比如说以query、find、get等开头的就走读库，其他的走写库。
  （1）写一个DynamicDataSource类 继承Spring的AbstractRoutingDataSource,只要实现determineCurrentLookupKey方法即可。
  （2）再写一个类DynamicDataSourceHolder,使用ThreadLocal技术来记录当前线程中的数据源的key；
  （3）订阅数据源的AOP切面，通过Service的方法名判断是应该走读库还是写库；
  （4）Spring的配置文件中配置数据源DataSource为自定义的DynamicDataSource，定义连接池，配置jdbc.properties；
  （5）配置事务管理以及动态切换数据源切面。
- **分库分表时的一致性hash算法？**
  对节点和数据，都做一个哈希运算，然后比较节点和数据的哈希值，数据取和节点最相近的节点作为存放节点。这样就保证当节点增加或者减少的时候，影响的数据最少。
  一种简单的办法，给每个真实结点后面根据虚拟节点加上后缀再取Hash值，比如&quot;192.168.0.0:111&quot;就把它变成&quot;192.168.0.0:111&amp;&amp;VN0&quot;到&quot;192.168.0.0:111&amp;&amp;VN4&quot;，VN就是Virtual Node的缩写，还原的时候只需要从头截取字符串到&quot;&amp;&amp;&quot;的位置就可以了。
</code></pre>

<h3 id="mybatis">mybatis</h3>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>mybatis如何映射表结构</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>Mybatis缓存机制？</strong>

<ul>
<li>一级缓存（默认）是SqlSession级别的缓存，它的作用域是SqlSession，在同一个SqlSession执行相同的SQL语句，第一次执行后会将结果集写到缓存中，第二次就会从缓存里获取。</li>
<li>二级缓存（默认不开启，需要手动在xml文件中配置），作用域是namespace。</li>
</ul></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>MyBatis的#号和$符号传参数的区别，$符号这种方式存在的意义，什么场景是一定要用$符号解决的？$和#可以同时用吗？</strong>

<ul>
<li><code>#</code>将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by #user_id#，如果传入的值是111,那么解析成sql时的值为order by &ldquo;111&rdquo;, 如果传入的值是id，则解析成的sql为order by &ldquo;id&rdquo;.</li>
<li><code>$</code>将传入的数据直接显示生成在sql中。如：order by $user_id$，如果传入的值是111,那么解析成sql时的值为order by user_id, 如果传入的值是id，则解析成的sql为order by id.</li>
<li><code>#</code>方式能够很大程度防止sql注入。　</li>
<li><code>$</code>方式无法防止Sql注入。</li>
<li><code>$</code>方式一般用于传入数据库对象，例如传入表名.　</li>
<li>一般能用<code>#</code>的就别用<code>$</code>.</li>
</ul></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>介绍一下Mybatis和主要的工作过程？</strong>

<ul>
<li>每一个Mybatis的应用程序都以一个SqlSessionFactory对象的实例为核心。首先用字节流通过Resource将配置文件读入，然后通过SqlSessionFactoryBuilder().build方法创建SqlSessionFactory，然后再通过SqlSessionFactory.openSession()方法创建一个SqlSession为每一个数据库事务服务。 经历了Mybatis初始化 –&gt;创建SqlSession –&gt;运行SQL语句，返回结果三个过程</li>
</ul></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>写出Mybatis动态sql语句中任意5个标签？</strong>
<br/>if、where、when、choose、otherwise</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>Mybatis分页时可以写分页的语句或者用到一个类, 这个类的名字叫？</strong>
RowBounds</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>(简答)如果Mybatis进行查询的时候实体类的属性名和数据库字段不一致怎么办 ?</strong>
用resultMap与之对应sql中使用别名</label></li>
</ul>

<h3 id="网络">网络</h3>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>TCP和UDP</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>三次握手协议</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>1、当我们在浏览器的地址栏输入www.google.com,然后回车，这一瞬间到看到页面到底发生了什么呢？</strong></label></li>
</ul>

<p>DNS域名解析 –&gt; 发起TCP的三次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如javascript、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户
- [ ] <strong>2、说下TCP三次握手的过程？</strong>
  - 第一次握手：建立连接时,客户端发送syn包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认；
SYN：同步序列编号(Synchronize Sequence Numbers)
  - 第二次握手：服务器收到syn包,必须确认客户的SYN（ack=j+1）,同时自己也发送一个SYN包（syn=k）,即SYN+ACK包,此时服务器进入SYN_RECV状态；
  - 第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手.
  - 完成三次握手,客户端与服务器开始传送数据
- [ ] <strong>3、HTTP和HTTPS的区别？</strong></p>

<p>CA证书、加密传输SSL、端口不同80和443、无状态和有状态。
- [ ] <strong>4、User-Agent、Host？</strong>
- [ ] <strong>5、Cookie、Session？</strong>
- [ ] <strong>6、什么是MIME？常用的有哪些？</strong></p>

<p>MIME规定了用于表示各种各样的数据类型的符号化方法。 此外，在万维网中使用的HTTP协议中也使用了MIME的框架，标准被扩展为互联网媒体类型。
- [ ] <strong>7、服务器返回给客户端http响应包的状态码有哪几大类？302、304分别是什么意思？</strong></p>

<pre><code class="language-text">1xx: 信息性状态码
    100, 101
2xx: 成功状态码
    200：OK
3xx: 重定向状态码
    301: 永久重定向, Location响应首部的值仍为当前URL，因此为隐藏重定向;
    302: 临时重定向，显式重定向, Location响应首部的值为新的URL
    304：Not Modified  未修改，比如本地缓存的资源文件和服务器上比较时，发现并没有修改，服务器返回一个304状态码，告诉浏览器，你不用请求该资源，直接使用本地的资源即可。
4xx: 客户端错误状态码
    404: Not Found  请求的URL资源并不存在
5xx: 服务器端错误状态码
    500: Internal Server Error  服务器内部错误
    502: Bad Gateway  前面代理服务器联系不到后端的服务器时出现
    504：Gateway Timeout  这个是代理能联系到后端的服务器，但是后端的服务器在规定的时间内没有给代理服务器响应
</code></pre>

<h3 id="算法">算法</h3>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> 5台服务器如何选出leader(选举算法)</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> 二叉树遍历</label></li>
</ul>

<h3 id="linux">linux</h3>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> 用awk统计一个ip文件中top10</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> top命令</label></li>
</ul>

<h3 id="性能优化">性能优化</h3>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>怎样诊断高CPU的应用</strong>

<ul>
<li><a href="http://www.voidcn.com/article/p-mlntccbq-nw.html" rel="nofollow noreferrer" target="_blank">http://www.voidcn.com/article/p-mlntccbq-nw.html</a></li>
<li><a href="https://www.jianshu.com/p/6d573e42310a" rel="nofollow noreferrer" target="_blank">https://www.jianshu.com/p/6d573e42310a</a></li>
</ul></label></li>
</ul>

<pre><code class="language-shell">top {pid}
top -Hp {pid}
printf &quot;%x\h&quot; nid
jstack {vmid}|grep {nid}
线程的状态：
NEW,未启动的。不会出现在Dump中。
RUNNABLE,在虚拟机内执行的。
BLOCKED,受阻塞并等待监视器锁。
WATING,无限期等待另一个线程执行特定操作。
TIMED_WATING,有时限的等待另一个线程的特定操作。
TERMINATED,已退出的。
</code></pre>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>组合索引知道最左原则，但针对多个列顺序问题不知道应该怎么考虑</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>当一个Java程序响应很慢时如何查找问题</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>当一个Java程序频繁FullGC时如何解决问题，如何查看垃圾回收日志</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>当一个Java应用发生OutOfMemory时该如何解决，年轻代、年老代、永久代解决办法不同，导致原因也不同</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>怎样诊断高CPU的应用</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>CAP只知道概念，什么是分区容忍答不上来</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>分布式系统高可用和扩展</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>jvm gc</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>分布式事务 二阶段提交</strong></label></li>
</ul>

<h3 id="开放思维">开放思维</h3>

<ul class="task-list">
<li><strong>文章</strong>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="https://segmentfault.com/a/1190000016172470" rel="nofollow noreferrer" target="_blank">https://segmentfault.com/a/1190000016172470</a></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="https://blog.csdn.net/sinat_35512245/article/details/60325685" rel="nofollow noreferrer" target="_blank">https://blog.csdn.net/sinat_35512245/article/details/60325685</a></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="https://zhuanlan.zhihu.com/p/33273041" rel="nofollow noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/33273041</a></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="https://segmentfault.com/a/1190000016985310" rel="nofollow noreferrer" target="_blank">https://segmentfault.com/a/1190000016985310</a></label></li>
</ul></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>设计一个生产者（文件读）消费者（把文件数据写到网络）模型，使用 wait、notify或其他方法实现</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>日志查找关键字</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>写一个死锁</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>责任链，排序</strong><br /></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>给出n个节点，标号分别从0到 n-1 并且给出一个无向边的列表 (给出每条边的两个顶点), 写一个函数去判断这张无向图是否是一棵树，假设我们不会给出重复的边在边的列表当中. 无向边 [0, 1] 和 [1, 0] 是同一条边， 因此他们不会同时出现在我们给你的边的列表当中。</strong>样例：</label></li>
</ul>

<pre><code class="language-text">          1) 给出n = 5 并且 edges = [0, 1], [0, 2], [0, 3], [1, 4], 返回 true.
          2) 给出n = 5 并且 edges = [0, 1], [1, 2], [2, 3], [1, 3], [1, 4], 返回 false.
</code></pre>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>一个有序数组，实现一个查找函数，找出指定元素在数组中第一次出现的位置，要求：时间复杂度最优；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>如何创建线程</strong>

<ul>
<li>第一种方法：继承Thread类，重写run()方法，run()方法代表线程要执行的任务。</li>
<li>第二种方法：实现Runnable接口，重写run()方法，run()方法代表线程要执行的任务。</li>
<li>第三种方法：实现callable接口，重写call()方法，call()作为线程的执行体，具有返回值，并且可以对异常进行声明和抛出</li>
</ul></label></li>
</ul>

<p>使用start()方法来启动线程
优点：因为JAVA是单继承机制，当我们继承Thread类后就不能继承其他类了，所以选用实现Runnable接口。
  - 1.通过实现Runnable接口来创建Thread线程：</p>

<pre><code class="language-text">步骤1：创建实现Runnable接口的类：   
Java代码 
  class SomeRunnable implements Runnable   { 
  public void run()   { 
  //do something here   }  
} 
  步骤2：创建一个类对象： 
  Runnable oneRunnable = new SomeRunnable();   
步骤3：由Runnable创建一个Thread对象：   
Thread oneThread = new Thread(oneRunnable);   
步骤4：启动线程：   
oneThread.start(); 
  至此，一个线程就创建完成了。 
  当调用完oneRunnable对象中的void run();方法后，线程就消亡了。
</code></pre>

<ul>
<li>2.通过继承Thread类来创建一个线程：<br /></li>
</ul>

<pre><code class="language-text">步骤1：定义一个继承Thread类的子类：   
Java代码 
  class SomeThead extends Thraad   { 
  public void run()   { 
  //do something here   }   } 
  步骤2：构造子类的一个对象： 
 SomeThread oneThread = new SomeThread();   
  步骤3：启动线程：   
 oneThread.start(); 
  至此，一个线程就创建完成了。
</code></pre>

<ul>
<li>3.通过Callable和Future创建线程</li>
</ul>

<pre><code class="language-text">（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。
（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。
（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。
（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值其中，Callable接口(也只有一个方法)定义如下：  
  Java代码 
  public interface Callable   { 
  V call() throws Exception;   } 
  步骤1：创建实现Callable接口的类SomeCallable(略);   
  步骤2：创建一个类对象： 
      Callable oneCallable = new SomeCallable(); 
  步骤3：由Callable创建一个FutureTask对象：   
    FutureTask oneTask = new FutureTask(oneCallable); 
  注释： FutureTask是一个包装器，它通过接受Callable来创建，它同时实现了 Future和Runnable接口。 
  步骤4：由FutureTask创建一个Thread对象：   
    Thread oneThread = new Thread(oneTask);   
  步骤5：启动线程：  
    oneThread.start(); 
  至此，一个线程就创建完成了。
</code></pre>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>每个单词是以26个大写或小写英文字母构成，可能含有非法字符，非构成单词的字符均视为单词间隔符，要求倒排后的单词间隔符以一个空格表示；如果原字符串中相邻单词间有多个间隔符时，倒排转换后也只允许出现一个空格间隔符，不用写main函数，只写字符串处理函数就可以；不用IDE，直接在网页上编写。</strong></label></li>
</ul>

<p>比如：
【输入】I am @!#$software1234engineer1234
【输出】engineer software am I**</p>

<pre><code class="language-java">String input = &quot;I am @!#$software1234engineer1234&quot;;
String replacedStr = input.replaceAll(&quot;[^a-zA-Z]&quot;,&quot; &quot;);

String [] splitedStr = replacedStr.split(&quot; &quot;);

Stack&lt;String&gt; stack = new Stack();
for (int i=0;i&lt;splitedStr.length;i++){
	  String str = splitedStr[i];
 if (!&quot; &quot;.equals(str)){
   stack.push(str);
 }
}

StringBuilder output = new StringBuilder();
for (int j=0;j&lt;stack.size();j++){
  output.append(stack.pop());
}
System.out.println(output.toString());
  
</code></pre>

<h3 id="扩展视野">扩展视野</h3>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> gRPC</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> fork/join</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> 并发和并行</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> lambda表达式</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> 异步

<ul>
<li>nio、netty</li>
<li>akka</li>
<li>reactor</li>
</ul></label></li>
</ul>

<h3 id="中间件">中间件</h3>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> memcache和redis的区别</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> redis能存哪些类型</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> dubbo</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> kafka</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> Zookeeper

<ul>
<li>Zookeeper 能够保障分布式场景下数据的一致性、有序性、原子性及可靠性，它的所有写入动作会在 Leader 节点持久化，并在集群过半数节点写入成功才会返回；它也能够支持节点的崩溃恢复以及客户端的最终一致性视图。对于分布式锁场景来说，数据一致性的保障、以及锁服务的容灾保障至关重要。</li>
<li>可以作为分布式锁的原因：可以生成临时有序节点，通过water机制关注上一个节点的变化达到公平锁的效果，使用Curator还可以保证锁可重入性; <a href="https://foreti.me/2019/02/24/zookeeper-distributed-locks/" rel="nofollow noreferrer" target="_blank">Zookeeper分布式锁分析</a></li>
<li>可以作为注册中心的原因：支持CP，高正数据的一致性；树形结构的目录服务，提供者创建的节点都是临时节点，一旦网络超时或者客户端关闭连接，节点就会删除，zk会将这些变更推送给调用方； <a href="https://www.jianshu.com/p/68a05b5af088" rel="nofollow noreferrer" target="_blank">文章1</a>、<a href="https://blog.csdn.net/qq_26222859/article/details/80817673" rel="nofollow noreferrer" target="_blank">文章2</a></li>
<li>后续可以学习的文章<a href="http://jm.taobao.org/2018/06/13/%E5%81%9A%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%EF%BC%9F/" rel="nofollow noreferrer" target="_blank">阿里巴巴为什么不用 ZooKeeper 做服务发现？</a></li>
</ul></label></li>
</ul>

    </div>
</div>

          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2010 - 2019</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://ftex.github.io/">j.c</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
    
    <script src="/js/vendor_no_gallery.min.js" async=""></script>
    
  



     </div>
  </body>
</html>
