<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="j.c">
  
  
  
  
  <link rel="next" href="http://ftex.github.io/about/" />
  <link rel="canonical" href="http://ftex.github.io/java_review/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
            | 飞雷神
       
  </title>
  <meta name="title" content=" | 飞雷神">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "http:\/\/ftex.github.io\/"
    },
    "articleSection" : "",
    "name" : "",
    "headline" : "",
    "description" : "多线程 文章 https:\/\/juejin.im\/post\/5b57b81af265da0f4b7a9ae5 https:\/\/blog.csdn.net\/SEU_Calvin\/article\/details\/52411531 http:\/\/ifeve.com\/15-java-faq\/ https:\/\/zhuanlan.zhihu.com\/p\/34678757 （讲解的比较详细）  [ ] java内存模型\nhttp:\/\/blog.csdn.net\/suifeng3051\/article\/details\/52611310  Java Memory Model(JMM)，定义了多线程之间共享变量的可见性和如何在需要的时候对共享变量进行同步。线程之间通讯分为共享内存和消息传递两种方式，java使用的是共享内存的方式。 从JVM角度来看，JMM就是决定一个线程对共享变量的写入何时对另一个线程可见，线程之间的共享变量存储在堆中的主内存(main memory)中，每个线程都在线程栈上有一个私有的本地内存(local memory)，本地内存中存储了该线程以读\/写共享变量的副本。 从硬件角度来看，我们的数据存储再内存中，负责计算的CPU每个核都有一组寄存器（也就是CPU的存储器），多个CPU缓存。处理速度：寄存器\x26gt;一级缓存\x26gt;二级缓存\x26gt;主内存，当CPU需要访问主内存中的数据的时候，会先读取一部分主内存数据到CPU缓存，再把CPU缓存的数据读取到寄存器。当CPU需要写入数据到主存时，同样会先flush寄存器到CPU缓存，再在某些节点把缓存数据flush到主存中。 通过上述两个角度我们可以看出对内存中数据的读取，我们需要解决数据的可见性和执行的顺序性，java提供了volatile和synchronized这两个关键字来解决这些问题。volatile关键字基于CPU内存屏障指令实现，保证一个线程对变量的写入可以对其他线程可见。synchronized代码块可以保证同一时刻只能有一个线程进入代码的竞争区，也能保证volatile的可见性，当线程退出代码块时，对变量的更新将会flush到主存中，不管这些变量是不是volatile类型的。    [ ] Thread方法的使用\n [ ] conncurrentHashmap的实现\n [ ] j.u.c下列类的实现，AQS\n [ ] synchronized原理\nhttps:\/\/blog.csdn.net\/javazejian\/article\/details\/72828483 https:\/\/blog.csdn.net\/chenssy\/article\/details\/54883355  [ ] java 线程池实现，拒绝策略\n [ ] synchronized原理\n [ ] 写一个死锁\n [ ] 现实工作中什么场景使用过多线程？简单介绍一个线程池 newCachedThreadPool、newFixedThreadPool、newScheduledThreadPool\n [ ] 什么是守护线程，守护线程和非守护线程的区别以及用法\n [ ] synchronized和volatile的作用\n 1. volatile关键字的作用  其实volatile关键字的作用就是保证了可见性和有序性（不保证原子性），如果一个共享变量被volatile关键字修饰，那么如果一个线程修改了这个共享变量后，其他线程是立马可知的。为什么是这样的呢？比如，线程A修改了自己的共享变量副本，这时如果该共享变量没有被volatile修饰，那么本次修改不一定会马上将修改结果刷新到主存中，如果此时B去主存中读取共享变量的值，那么这个值就是没有被A修改之前的值。如果该共享变量被volatile修饰了，那么本次修改结果会强制立刻刷新到主存中，如果此时B去主存中读取共享变量的值，那么这个值就是被A修改之后的值了。 volatile能禁止指令重新排序，在指令重排序优化时，在volatile变量之前的指令不能在volatile之后执行，在volatile之后的指令也不能在volatile之前执行，所以它保证了有序性。 2.",
    "inLanguage" : "en-us",
    "author" : "j.c",
    "creator" : "j.c",
    "publisher": "j.c",
    "accountablePerson" : "j.c",
    "copyrightHolder" : "j.c",
    "copyrightYear" : "0001",
    "datePublished": "0001-01-01 00:00:00 \x2b0000 UTC",
    "dateModified" : "0001-01-01 00:00:00 \x2b0000 UTC",
    "url" : "http:\/\/ftex.github.io\/java_review\/",
    "wordCount" : "953",
    "keywords" : [  "飞雷神"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="http://ftex.github.io/">飞雷神</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/post/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="http://ftex.github.io/">飞雷神</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/post/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<div class="post-warp archive">
    <h2 class="post-title" style="text-align:right;padding-bottom:2em"></h2>
    <div class="post-content">
        

<h3 id="多线程">多线程</h3>

<ul class="task-list">
<li><strong>文章</strong>

<ul class="task-list">
<li><label><input type="checkbox" checked disabled class="task-list-item"> <a href="https://juejin.im/post/5b57b81af265da0f4b7a9ae5" rel="nofollow noreferrer" target="_blank">https://juejin.im/post/5b57b81af265da0f4b7a9ae5</a></label></li>
<li><label><input type="checkbox" checked disabled class="task-list-item"> <a href="https://blog.csdn.net/SEU_Calvin/article/details/52411531" rel="nofollow noreferrer" target="_blank">https://blog.csdn.net/SEU_Calvin/article/details/52411531</a></label></li>
<li><label><input type="checkbox" checked disabled class="task-list-item"> <a href="http://ifeve.com/15-java-faq/" rel="nofollow noreferrer" target="_blank">http://ifeve.com/15-java-faq/</a></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="https://zhuanlan.zhihu.com/p/34678757" rel="nofollow noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/34678757</a>  （讲解的比较详细）</label></li>
</ul></li>

<li><p>[ ] <strong>java内存模型</strong></p>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="http://blog.csdn.net/suifeng3051/article/details/52611310" rel="nofollow noreferrer" target="_blank">http://blog.csdn.net/suifeng3051/article/details/52611310</a>

<ul>
<li>Java Memory Model(<strong>JMM</strong>)，定义了多线程之间共享变量的可见性和如何在需要的时候对共享变量进行同步。线程之间通讯分为<strong>共享内存</strong>和<strong>消息传递</strong>两种方式，java使用的是<strong>共享内存</strong>的方式。</li>
<li><strong>从JVM角度来看</strong>，JMM就是决定一个线程对共享变量的写入何时对另一个线程可见，线程之间的共享变量存储在堆中的主内存(main memory)中，每个线程都在线程栈上有一个私有的本地内存(local memory)，本地内存中存储了该线程以读/写共享变量的副本。</li>
<li><strong>从硬件角度来看</strong>，我们的数据存储再内存中，负责计算的CPU每个核都有一组寄存器（也就是CPU的存储器），多个CPU缓存。处理速度：<strong>寄存器&gt;一级缓存&gt;二级缓存&gt;主内存</strong>，当CPU需要访问主内存中的数据的时候，会先读取一部分主内存数据到CPU缓存，再把CPU缓存的数据读取到寄存器。当CPU需要写入数据到主存时，同样会先flush寄存器到CPU缓存，再在某些节点把缓存数据flush到主存中。</li>
<li>通过上述两个角度我们可以看出对内存中数据的读取，我们需要解决数据的可见性和执行的顺序性，java提供了<code>volatile</code>和<code>synchronized</code>这两个关键字来解决这些问题。<code>volatile</code>关键字基于CPU内存屏障指令实现，保证一个线程对变量的写入可以对其他线程可见。<code>synchronized</code>代码块可以保证同一时刻只能有一个线程进入代码的竞争区，也能保证<code>volatile</code>的可见性，当线程退出代码块时，对变量的更新将会flush到主存中，不管这些变量是不是volatile类型的。
<br />
<br /></li>
</ul></label></li>
</ul></li>

<li><p>[ ] <strong>Thread方法的使用</strong></p></li>

<li><p>[ ] <strong>conncurrentHashmap的实现</strong></p></li>

<li><p>[ ] <strong>j.u.c下列类的实现，AQS</strong></p></li>

<li><p>[ ] <strong>synchronized原理</strong></p>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="https://blog.csdn.net/javazejian/article/details/72828483" rel="nofollow noreferrer" target="_blank">https://blog.csdn.net/javazejian/article/details/72828483</a></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="https://blog.csdn.net/chenssy/article/details/54883355" rel="nofollow noreferrer" target="_blank">https://blog.csdn.net/chenssy/article/details/54883355</a></label></li>
</ul></li>

<li><p>[ ] <strong>java 线程池实现，拒绝策略</strong></p></li>

<li><p>[ ] <strong>synchronized原理</strong></p></li>

<li><p>[ ] <strong>写一个死锁</strong></p></li>

<li><p>[ ] <strong>现实工作中什么场景使用过多线程？简单介绍一个线程池</strong>
newCachedThreadPool、newFixedThreadPool、newScheduledThreadPool</p></li>

<li><p>[ ] <strong>什么是守护线程，守护线程和非守护线程的区别以及用法</strong></p></li>

<li><p>[ ] <strong>synchronized和volatile的作用</strong></p>

<ul>
<li>1. volatile关键字的作用
<br/> 其实volatile关键字的作用就是保证了可见性和有序性（不保证原子性），如果一个共享变量被volatile关键字修饰，那么如果一个线程修改了这个共享变量后，其他线程是立马可知的。为什么是这样的呢？比如，线程A修改了自己的共享变量副本，这时如果该共享变量没有被volatile修饰，那么本次修改不一定会马上将修改结果刷新到主存中，如果此时B去主存中读取共享变量的值，那么这个值就是没有被A修改之前的值。如果该共享变量被volatile修饰了，那么本次修改结果会强制立刻刷新到主存中，如果此时B去主存中读取共享变量的值，那么这个值就是被A修改之后的值了。
volatile能禁止指令重新排序，在指令重排序优化时，在volatile变量之前的指令不能在volatile之后执行，在volatile之后的指令也不能在volatile之前执行，所以它保证了有序性。</li>
<li>2. synchronized关键字的作用
<br/> synchronized提供了同步锁的概念，被synchronized修饰的代码段可以防止被多个线程同时执行，必须一个线程把synchronized修饰的代码段都执行完毕了，其他的线程才能开始执行这段代码。
因为synchronized保证了在同一时刻，只能有一个线程执行同步代码块，所以执行同步代码块的时候相当于是单线程操作了，那么线程的可见性、原子性、有序性（线程之间的执行顺序）它都能保证了。</li>
<li>3. volatile关键字和synchronized关键字的区别

<ul>
<li>volatile只能作用于变量，使用范围较小。synchronized可以用在变量、方法、类、同步代码块等，使用范围比较广。</li>
<li>volatile只能保证可见性和有序性，不能保证原子性。而可见性、有序性、原子性synchronized都可以包证。</li>
<li>volatile不会造成线程阻塞。synchronized可能会造成线程阻塞。</li>
</ul></li>
</ul></li>

<li><p>[ ] <strong>线程安全</strong></p>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> ArrayList和Vector有什么区别?</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> HashMap和HashTable有什么区别?</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> StringBuilder和StringBuffer有什么区别?</label></li>
</ul>

<p>这些都是Java面试中常见的基础问题。面对这样的问题，回答是：ArrayList是非线程安全的，Vector是线程安全的；HashMap是非线程安全的，HashTable是线程安全的；StringBuilder是非线程安全的，StringBuffer是线程安全的。</p>

<p>此时如果继续问：什么是线程安全？线程安全和非线程安全有什么区别？分别在什么情况下使用？</p>

<p>线程安全：
当多个线程类并发操作某类的某个方法，(在该方法内部)来修改这个类的某个成员变量的值，不会出错，则我们就说，该的这个方法是线程安全的。</p>

<p>某类的某方法是否线程安全的关键是：
 - 该方法是否修改该类的成员变量;
 - 是否给该方法加锁(是否用synchronized关键字修饰）。
线程不安全：
 <br/> 当多个线程类并发操作某类的某个方法，(在该方法内部)来修改这个类的某个成员变量的值，很容易就会发生错误，故我们就说，这个方法是线程不安全的。如果要把这个方法变成线程安全的，则用 synchronized关键字来修饰该方法即可。</p>

<p>总结：若多个线程同时修改某个外部传来的对象的成员变量，很容易就会出现错误，我们称之为线程不安全。(该类的这个方法是线程不安全的。若要线程安全，用synchronized关键字修饰即可)。</p></li>
</ul>

<h3 id="jvm">JVM</h3>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> 逃逸分析</label></li>
<li>文章：

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="https://blog.csdn.net/jisuanjiguoba/article/details/80176223" rel="nofollow noreferrer" target="_blank">https://blog.csdn.net/jisuanjiguoba/article/details/80176223</a></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="http://www.cnblogs.com/zhguang/p/Java-JVM-GC.html" rel="nofollow noreferrer" target="_blank">http://www.cnblogs.com/zhguang/p/Java-JVM-GC.html</a></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="https://blog.csdn.net/aoxida/article/details/45061571" rel="nofollow noreferrer" target="_blank">https://blog.csdn.net/aoxida/article/details/45061571</a></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="https://blog.csdn.net/zp357252539/article/details/52197708" rel="nofollow noreferrer" target="_blank">https://blog.csdn.net/zp357252539/article/details/52197708</a></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> java内存管理参考资料：

<ul class="task-list">
<li><a href="http://www.importnew.com/21463.html" rel="nofollow noreferrer" target="_blank">http://www.importnew.com/21463.html</a></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="http://www.cnblogs.com/gw811/archive/2012/10/18/2730117.html" rel="nofollow noreferrer" target="_blank">http://www.cnblogs.com/gw811/archive/2012/10/18/2730117.html</a> (java内存管理)</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="http://blog.csdn.net/tutngfei1129287460/article/details/7383480" rel="nofollow noreferrer" target="_blank">http://blog.csdn.net/tutngfei1129287460/article/details/7383480</a> (java内存管理机制
)</label></li>
</ul></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> java堆和栈

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="http://blog.csdn.net/emira_j/article/details/51232611" rel="nofollow noreferrer" target="_blank">http://blog.csdn.net/emira_j/article/details/51232611</a></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="http://www.cnblogs.com/whgw/archive/2011/09/29/2194997.html" rel="nofollow noreferrer" target="_blank">http://www.cnblogs.com/whgw/archive/2011/09/29/2194997.html</a></label></li>
</ul></label></li>
</ul></li>
<li><label><input type="checkbox" disabled class="task-list-item"> 垃圾回收机制</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> 简单介绍下JVM各种参数及调优</label></li>
</ul>

<h3 id="数据结构和基础知识">数据结构和基础知识</h3>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>synchronized和volatile的作用</strong></label></li>

<li><p>[ ] <strong>StringBuilder 和 StringBuffer 的区别是什么？什么时候该用 + 来拼接字符串？什么时候该用StringBuilder ？什么时候该用 StringBuffer ？</strong></p>

<p>这三个类之间的区别主要是在两个方面，即运行速度和线程安全这两方面。</p>

<ul>
<li>首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String。String最慢的原因：String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。</li>
<li>再来说线程安全，在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的
如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。一般单线程操作中，可以在一行代码中拼接完的字符串操作，都用 + 操作符就可以了，因为 + 操作符默认会使用 StringBuilder 来拼接；如果单线程操作中，拼接字符串需要使用循环，那么直接使用 StringBuilder 比较合适；如果在拼接字符串的操作处于多线程环境中，需要使用 StringBuffer 来操作。

<ul>
<li>String：适用于少量的字符串操作的情况；</li>
<li>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况；</li>
<li>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况；</li>
</ul></li>
</ul>

<p><a href="https://segmentfault.com/a/1190000007099818" rel="nofollow noreferrer" target="_blank">https://segmentfault.com/a/1190000007099818</a>
<a href="https://www.cnblogs.com/shanheyongmu/p/9583381.html" rel="nofollow noreferrer" target="_blank">https://www.cnblogs.com/shanheyongmu/p/9583381.html</a></p></li>

<li><p>[ ] <strong>如果碰到多重循环需要跳出该如何操作？</strong></p>

<p>可以使用循环标签，即在循环关键字前加上一个标签名及冒号，在需要跳出的地方（ break ${labelName} 或 continue ${labelName} ）进行跳出。</p></li>

<li><p>[ ] <strong>HashMap的实现原理</strong></p>

<ul>
<li>1. 利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</li>
<li>2. 存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中</li>
<li>3. 获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</li>
<li>4. 理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</li>
</ul></li>

<li><p>[ ] <strong>HashMap与HashTable的区别？</strong></p>

<ul>
<li>1. HashMap是非线程安全的，HashTable是线程安全的。</li>
<li>2. HashMap的键和值都允许有null值存在，而HashTable则不行。 3、因为线程安全的问题，HashMap效率比HashTable的要高。</li>
</ul></li>

<li><p>[ ] <strong>进程和线程的区别与联系？</strong>
<br/> 进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1–n个线程。
线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。
<br/> 线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。</p></li>

<li><p>[ ] <strong>在java中要想实现多线程，有几种方法？</strong>
<br/> 一种是继续Thread类，另外一种是实现Runable接口，还有就是实现Callable接口。</p></li>

<li><p>[ ] <strong>switch能否用string做参数？</strong>
<br/> 在 Java 7 之前, switch 只能支持byte,short,char,int 或者其对应的封装类以及 Enum 类型。在Java 7中,String 支持被加上了。
Java7编译器进行了优化，String比较的原理是先使用hashCode判断，再通过equals判断值是否相等。</p></li>

<li><p>[ ] <strong>Object有哪些公用方法？</strong></p>

<ul>
<li>1. 方法equals测试的是两个对象是否相等</li>
<li>2. 方法clone进行对象拷贝</li>
<li>3. 方法getClass返回和当前对象相关的Class对象</li>
<li>4. 方法notify,notifyall,wait都是用来对给定对象进行线程同步的</li>
</ul></li>

<li><p>[ ] <strong>Java的四种引用以及应用场景？</strong></p>

<ul>
<li><strong>强引用</strong>：如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。</li>
<li><strong>软引用</strong>：在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。</li>
<li><strong>弱引用</strong>：具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象。</li>
<li><strong>虚引用</strong>：顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。</li>
</ul></li>

<li><p>[ ] <strong>抽象类和接口的区别？</strong></p>

<ul>
<li>一个类只能继承单个类，但是可以实现多个接口</li>
<li>抽象类中可以有构造方法，接口中不能有构造方法</li>
<li>抽象类中的所有方法并不一定要是抽象的，你可以选择在抽象类中实现一些基本的方法。而接口要求所有的方法都必须是抽象的</li>
<li>抽象类中可以包含静态方法，接口中不可以</li>
<li>抽象类中可以有普通成员变量，接口中不可以</li>
</ul></li>

<li><p>[ ] <strong>ThreadLocal</strong></p>

<ul>
<li>用于保存某个线程共享变量：对于同一个static ThreadLocal，不同线程只能从中get，set，remove自己的变量，而不会影响其他线程的变量。</li>
</ul></li>

<li><p>[ ] <strong>ConcurrentHashmap的锁是如何加的？是不是分段越多越好?</strong></p></li>

<li><p>[ ] <strong>concurrenhashmap求size是如何加锁的，如果刚求完一段后这段发生了变化该如何处理</strong></p></li>

<li><p>[ ] <strong>并发队列ConcurrentLinkedQueue和阻塞队列LinkedBlockingQueue用法</strong></p></li>

<li><p>[ ] <strong>读写锁</strong></p></li>

<li><p>[ ] <strong>可重入的读写锁，可重入是如何实现的？</strong></p></li>

<li><p>[ ] <strong>List，Map，Set接口，Collection接口差异</strong></p>

<ul>
<li>List,Set都是继承自Collection接口，Map则不是；</li>
<li>List特点：元素有放入顺序，元素可重复 ，Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。）</li>
<li>Set和List对比：

<ul>
<li>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。</li>
<li>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。</li>
</ul></li>
<li>Map适合储存键值对的数据；</li>
<li>线程安全集合类与非线程安全集合类；

<ul>
<li>LinkedList、ArrayList、HashSet是非线程安全的，Vector是线程安全的;</li>
<li>HashMap是非线程安全的，HashTable是线程安全的;</li>
</ul></li>
</ul></li>

<li><p>[ ] <strong>java序列化的作用和原理</strong></p>

<ul>
<li>Java序列化算法透析

<ul>
<li>Serialization（序列化）是一种将对象以一连串的字节描述的过程；反序列化deserialization是一种将这些字节重建成一个对象的过程。Java序列化API提供一种处理对象序列化的标准机制。在这里你能学到如何序列化一个对象，什么时候需要序列化以及Java序列化的算法，我们用一个实例来示范序列化以后的字节是如何描述一个对象的信息的。</li>
</ul></li>
<li>序列化的必要性

<ul>
<li>Java中，一切都是对象，在分布式环境中经常需要将Object从这一端网络或设备传递到另一端。这就需要有一种可以在两端传输数据的协议。Java序列化机制就是为了解决这个问题而产生。</li>
</ul></li>
<li>如何序列化一个对象</li>
<li>一个对象能够序列化的前提是实现Serializable接口，Serializable接口没有方法，更像是个标记。有了这个标记的Class就能被序列化机制处理。</li>
<li>为什么要用序列化</li>
<li>是因为在分布式的系统中有时候我们需要对象的传递，但是对象没有用中间件之类的配置，所以现在怎么把对象传递过去呢，我们能想到的就是把对象转成成字节存储到一个文件中，其中这个字节中既包括对象，也包括对象中存储的数据，也就是对象实例，当用的时候，在从这个文件中把存到硬盘中的字节流文件转成成对象。在这其中把对象和对象实例转化成字节流并存储到字节流文件中的过程就叫序列化，而从字节流文件中读取文件的过程就叫做反序列化。</li>
</ul></li>

<li><p>[ ] <strong>重写equals方法的时候为什么要重写hashcode方法？</strong></p>

<ul>
<li>如果申明一个对象作为map的key，那么map会比较key的hashCode()，和equals()方法 来确定是否存在这个key。2.如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用hashCode 方法都必须生成相同的整数结果。</li>
</ul></li>
</ul>

<pre><code class="language-java"> do {
     if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e;
  } while ((e = e.next) != null);
</code></pre>

<h3 id="分布式">分布式</h3>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> 分布式事务、治理、一致性</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> 服务限流、熔断</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> 领域驱动设计的思想，只需要懂</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> 分布式事务 二阶段提交</label></li>
</ul>

<h3 id="spring">spring</h3>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>1.Spring的注入bean的方式</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>2.SpringMVC运行原理？</strong>

<ul>
<li>1. 客户端请求提交到DispatcherServlet；</li>
<li>2. 由DispatcherServlet控制器查询HandlerMapping，找到并分发到指定的Controller中；</li>
<li>3. Controller调用业务逻辑处理后，返回ModelAndView；</li>
<li>4. DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图；</li>
<li>5. 视图负责将结果显示到客户端。</li>
</ul></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>3.Spring IOC （控制反转，依赖注入）？</strong>

<ul>
<li>Spring支持三种依赖注入方式，分别是属性（Setter方法）注入，构造注入和接口注入。</li>
<li>Spring的IOC容器通过反射的机制实例化Bean并建立Bean之间的依赖关系。</li>
</ul></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>4.Spring Bean的作用域？</strong>

<ul>
<li>Singleton：Spring IOC容器中只有一个共享的Bean实例，一般都是Singleton作用域。</li>
<li>Prototype：每一个请求，会产生一个新的Bean实例。</li>
<li>Request：每一次http请求会产生一个新的Bean实例。</li>
</ul></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>Spring中 Bean生命周期</strong>
<br/> Spring IOC容器可以管理Bean的生命周期，允许在Bean生命周期的特定点执行定制的任务。
Spring IOC容器对Bean的生命周期进行管理的过程如下：

<ul>
<li>1. 通过构造器或工厂方法创建Bean实例</li>
<li>2. 为Bean的属性设置值和对其它Bean的引用</li>
<li>3. 调用Bean的初始化方法</li>
<li>4. Bean可以使用了</li>
<li>5. 当容器关闭时，调用Bean的销毁方法</li>
<li>6. 在 Bean 的声明里设置 init-method 和 destroy-method 属性, 为 Bean 指定初始化和销毁方法。</li>
</ul></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>5.Spring的基本框架主要包含哪些模块？</strong>

<ul>
<li>Spring DAO：Spring提供了对JDBC的操作支持：JdbcTemplate模板工具类 。</li>
<li>Spring ORM：Spring可以与ORM框架整合。例如Spring整合Hibernate框架，其中Spring还提供HibernateDaoSupport工具类，简化了Hibernate的操作 。</li>
<li>Spring WEB：Spring提供了对Struts、Springmvc的支持，支持WEB开发。与此同时Spring自身也提供了基于MVC的解决方案 。</li>
<li>Spring AOP：Spring提供面向切面的编程，可以给某一层提供事务管理，例如在Service层添加事物控制 。</li>
<li>Spring JEE：J2EE开发规范的支持，例如EJB 。</li>
<li>Spring Core：提供IOC容器对象的创建和处理依赖对象关系 。</li>
</ul></label></li>

<li><p>[ ] <strong>6.Spring AOP？</strong></p>

<ul>
<li>JDK动态代理：调用者实际调用的则是代理类的方法，通过这种方式我们就可以在代理类中织入切面逻辑；</li>
<li>Cglib：通过为目标类动态生成一个子类，通过在子类中织入相应逻辑来达到织入代理逻辑的目的</li>
<li>AspectJ:静态织入，它有专门的编译器，在编译期间将Advice以字节码的形式织入到class文件中。</li>
<li>Spring AOP</li>
<li>切面（Aspect）：其实就是共有功能的实现。如日志切面、权限切面、事务切面等。在实际应用中通常是一个存放共有功能实现的普通Java类，之所以能被AOP容器识别成切面，是在配置中指定的。</li>
<li>通知（Advice）：是切面的具体实现。以目标方法为参照点，根据放置的地方不同，可分为前置通知（Before）、后置通知（AfterReturning）、异常通知（AfterThrowing）、最终通知（After）与环绕通知（Around）5种。在实际应用中通常是切面类中的一个方法，具体属于哪类通知，同样是在配置中指定的。</li>
<li>连接点（Joinpoint）：就是程序在运行过程中能够插入切面的地点。例如，方法调用、异常抛出或字段修改等，但Spring只支持方法级的连接点。</li>
<li>切入点（Pointcut）：用于定义通知应该切入到哪些连接点上。不同的通知通常需要切入到不同的连接点上，这种精准的匹配是由切入点的正则表达式来定义的。</li>
<li>目标对象（Target）：就是那些即将切入切面的对象，也就是那些被通知的对象。这些对象中已经只剩下干干净净的核心业务逻辑代码了，所有的共有功能代码等待AOP容器的切入。</li>
<li>代理对象（Proxy）：将通知应用到目标对象之后被动态创建的对象。可以简单地理解为，代理对象的功能等于目标对象的核心业务逻辑功能加上共有功能。代理对象对于使用者而言是透明的，是程序运行过程中的产物。</li>
<li>织入（Weaving）：将切面应用到目标对象从而创建一个新的代理对象的过程。这个过程可以发生在编译期、类装载期及运行期，当然不同的发生点有着不同的前提条件。譬如发生在编译期的话，就要求有一个支持这种AOP实现的特殊编译器；发生在类装载期，就要求有一个支持AOP实现的特殊类装载器；只有发生在运行期，则可直接通过Java语言的反射机制与动态代理机制来动态实现。
<br /></li>
</ul></li>

<li><p>[ ] <strong>7.将一个请求url指向一个类的方法的注解是？</strong>
@RequestMapping</p></li>

<li><p>[ ] <strong>8.将前台的form中input控件的name属性绑定到控制器类中的方法参数的注解是？</strong>
@RequestParam</p></li>

<li><p>[ ] <strong>spring事务的实现</strong>
<br/> 可以进一步了解下事务的配置，例如7中事务传播行为随机选择一个作介绍</p></li>

<li><p>[ ] <strong>IOC实现机制</strong></p></li>

<li><p>[ ] <strong>ApplicationContext 和 BeanFactory 的区别？</strong>
<br/> 创建 Bean 对象的时机不同：</p>

<ul>
<li>BeanFactory 采取延迟加载，第一次调用 getBean() 方法时才会初始化 Bean。</li>
<li>ApplicationContext 是加载完 applicationContext.xml 时，就创建具体的 Bean 对象的实例。（只对 BeanDefition 中描述为是单例的 bean，才进行饿汉式加载）</li>
</ul></li>
</ul>

<h3 id="数据库">数据库</h3>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>读写分离何时强制要读主库，读哪个从库是通过什么方式决定的，从库的同步mysql用的什么方式；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>主从复制；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>mysql的binlog</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>mysql的存储引擎；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>mysql引擎区别；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>myisam的优点，和innodb的区别</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>innodb对一行数据的读会枷锁吗？不枷锁，读实际读的是副本</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>myisam和innodb的区别（innodb是行级锁，myisam是表级锁）</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>mysql的默认隔离级别，其他隔离级别；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>求表的size，或做数据统计可用什么存储引擎；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>读多写少可用什么引擎；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>假如要统计多个表应该用什么引擎；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>select xx from xx where xx and xx order by xx limit xx； 如何优化这个（看explain）；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>左连接和右连接</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>sql语句各种条件的执行顺序，如select， where， order by， group by</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>mysql的行级锁加在哪个位置；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>行锁、表锁、列锁</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>乐观锁、悲观锁</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>mysql其他的性能优化方式；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>mysql是如何实现事务的；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>事务隔离级别；</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>select、update</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>简单说一说drop、delete与truncate的区别？</strong>
delete和truncate只删除表的数据不删除表的结构
速度,一般来说: drop&gt; truncate &gt;delete 
delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效; 如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>索引是什么？什么作用？优缺点？</strong>
索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构。
普通索引、唯一索引、主键索引、全文索引。</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>数据库事务是什么？</strong>
事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。
ACID：即原子性、一致性、隔离线和持久性。</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>HBase和mysql的区别。</strong></label></li>
</ul>

<pre><code class="language-text">HBase基于列存储，查询中的选中规则是通过列来定义，因此整个数据库是自动索引化的。HBase无需考虑分库、分表，它可以对存储的数据自动切分数据，并支持高并发读写操作，使得海量数据存储自动具有更强的扩展性。但是HBase不包含事务，没有表与表之间关联查询，
mysql基于行存储，mysql的innodb引擎带事务控制，表之间的join比较方便；伸缩性比较差。
</code></pre>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>mysql如何自己实现读写分离？</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>cobar, Amoeba原理</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>如何在应用层实现mysql读写分离？</strong></label></li>
</ul>

<pre><code class="language-text"> 这个就是平时用到的，所以说的比较详细：
  总的来说，在进入Service之前，使用AOP来做出判断，是使用写库还是读库，判断依据可以根据方法名判断，比如说以query、find、get等开头的就走读库，其他的走写库。
  （1）写一个DynamicDataSource类 继承Spring的AbstractRoutingDataSource,只要实现determineCurrentLookupKey方法即可。
  （2）再写一个类DynamicDataSourceHolder,使用ThreadLocal技术来记录当前线程中的数据源的key；
  （3）订阅数据源的AOP切面，通过Service的方法名判断是应该走读库还是写库；
  （4）Spring的配置文件中配置数据源DataSource为自定义的DynamicDataSource，定义连接池，配置jdbc.properties；
  （5）配置事务管理以及动态切换数据源切面。
- **分库分表时的一致性hash算法？**
  对节点和数据，都做一个哈希运算，然后比较节点和数据的哈希值，数据取和节点最相近的节点作为存放节点。这样就保证当节点增加或者减少的时候，影响的数据最少。
  一种简单的办法，给每个真实结点后面根据虚拟节点加上后缀再取Hash值，比如&quot;192.168.0.0:111&quot;就把它变成&quot;192.168.0.0:111&amp;&amp;VN0&quot;到&quot;192.168.0.0:111&amp;&amp;VN4&quot;，VN就是Virtual Node的缩写，还原的时候只需要从头截取字符串到&quot;&amp;&amp;&quot;的位置就可以了。
</code></pre>

<h3 id="mybatis">mybatis</h3>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>mybatis如何映射表结构</strong></label></li>

<li><p>[ ] <strong>Mybatis缓存机制？</strong></p>

<ul>
<li>一级缓存（默认）是SqlSession级别的缓存，它的作用域是SqlSession，在同一个SqlSession执行相同的SQL语句，第一次执行后会将结果集写到缓存中，第二次就会从缓存里获取。</li>
<li>二级缓存（默认不开启，需要手动在xml文件中配置），作用域是namespace。</li>
</ul></li>

<li><p>[ ] <strong>MyBatis的#号和$符号传参数的区别，$符号这种方式存在的意义，什么场景是一定要用$符号解决的？$和#可以同时用吗？</strong></p>

<ul>
<li><code>#</code>将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by #user_id#，如果传入的值是111,那么解析成sql时的值为order by &ldquo;111&rdquo;, 如果传入的值是id，则解析成的sql为order by &ldquo;id&rdquo;.</li>
<li><code>$</code>将传入的数据直接显示生成在sql中。如：order by $user_id$，如果传入的值是111,那么解析成sql时的值为order by user_id, 如果传入的值是id，则解析成的sql为order by id.</li>
<li><code>#</code>方式能够很大程度防止sql注入。　</li>
<li><code>$</code>方式无法防止Sql注入。</li>
<li><code>$</code>方式一般用于传入数据库对象，例如传入表名.　</li>
<li>一般能用<code>#</code>的就别用<code>$</code>.</li>
</ul></li>

<li><p>[ ] <strong>介绍一下Mybatis和主要的工作过程？</strong></p>

<ul>
<li>每一个Mybatis的应用程序都以一个SqlSessionFactory对象的实例为核心。首先用字节流通过Resource将配置文件读入，然后通过SqlSessionFactoryBuilder().build方法创建SqlSessionFactory，然后再通过SqlSessionFactory.openSession()方法创建一个SqlSession为每一个数据库事务服务。 经历了Mybatis初始化 –&gt;创建SqlSession –&gt;运行SQL语句，返回结果三个过程</li>
</ul></li>

<li><p>[ ] <strong>写出Mybatis动态sql语句中任意5个标签？</strong></p></li>
</ul>

<p>if、where、when、choose、otherwise
- [ ] <strong>Mybatis分页时可以写分页的语句或者用到一个类, 这个类的名字叫？</strong></p>

<p>RowBounds
- [ ] <strong>(简答)如果Mybatis进行查询的时候实体类的属性名和数据库字段不一致怎么办 ?</strong></p>

<p>用resultMap与之对应sql中使用别名</p>

<h3 id="网络">网络</h3>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>TCP和UDP</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>三次握手协议</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>1、当我们在浏览器的地址栏输入www.google.com,然后回车，这一瞬间到看到页面到底发生了什么呢？</strong></label></li>
</ul>

<p>DNS域名解析 –&gt; 发起TCP的三次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如javascript、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户
- [ ] <strong>2、说下TCP三次握手的过程？</strong>
  - 第一次握手：建立连接时,客户端发送syn包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认；
SYN：同步序列编号(Synchronize Sequence Numbers)
  - 第二次握手：服务器收到syn包,必须确认客户的SYN（ack=j+1）,同时自己也发送一个SYN包（syn=k）,即SYN+ACK包,此时服务器进入SYN_RECV状态；
  - 第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手.
  - 完成三次握手,客户端与服务器开始传送数据
- [ ] <strong>3、HTTP和HTTPS的区别？</strong></p>

<p>CA证书、加密传输SSL、端口不同80和443、无状态和有状态。
- [ ] <strong>4、User-Agent、Host？</strong>
- [ ] <strong>5、Cookie、Session？</strong>
- [ ] <strong>6、什么是MIME？常用的有哪些？</strong></p>

<p>MIME规定了用于表示各种各样的数据类型的符号化方法。 此外，在万维网中使用的HTTP协议中也使用了MIME的框架，标准被扩展为互联网媒体类型。
- [ ] <strong>7、服务器返回给客户端http响应包的状态码有哪几大类？302、304分别是什么意思？</strong></p>

<pre><code class="language-text">1xx: 信息性状态码
    100, 101
2xx: 成功状态码
    200：OK
3xx: 重定向状态码
    301: 永久重定向, Location响应首部的值仍为当前URL，因此为隐藏重定向;
    302: 临时重定向，显式重定向, Location响应首部的值为新的URL
    304：Not Modified  未修改，比如本地缓存的资源文件和服务器上比较时，发现并没有修改，服务器返回一个304状态码，告诉浏览器，你不用请求该资源，直接使用本地的资源即可。
4xx: 客户端错误状态码
    404: Not Found  请求的URL资源并不存在
5xx: 服务器端错误状态码
    500: Internal Server Error  服务器内部错误
    502: Bad Gateway  前面代理服务器联系不到后端的服务器时出现
    504：Gateway Timeout  这个是代理能联系到后端的服务器，但是后端的服务器在规定的时间内没有给代理服务器响应
</code></pre>

<h3 id="算法">算法</h3>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> 5台服务器如何选出leader(选举算法)</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> 二叉树遍历</label></li>
</ul>

<h3 id="linux">linux</h3>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> 用awk统计一个ip文件中top10</label></li>

<li><p>[ ] top命令</p>

<h3 id="性能优化">性能优化</h3></li>

<li><p>[ ] <strong>怎样诊断高CPU的应用</strong></p>

<ul class="task-list">
<li><a href="http://www.voidcn.com/article/p-mlntccbq-nw.html" rel="nofollow noreferrer" target="_blank">http://www.voidcn.com/article/p-mlntccbq-nw.html</a></li>

<li><p><a href="https://www.jianshu.com/p/6d573e42310a" rel="nofollow noreferrer" target="_blank">https://www.jianshu.com/p/6d573e42310a</a></p>

<pre><code class="language-shell">top {pid}
top -Hp {pid}
printf &quot;%x\h&quot; nid
jstack {vmid}|grep {nid}
线程的状态：
NEW,未启动的。不会出现在Dump中。
RUNNABLE,在虚拟机内执行的。
BLOCKED,受阻塞并等待监视器锁。
WATING,无限期等待另一个线程执行特定操作。
TIMED_WATING,有时限的等待另一个线程的特定操作。
TERMINATED,已退出的。

</code></pre>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>组合索引知道最左原则，但针对多个列顺序问题不知道应该怎么考虑</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>当一个Java程序响应很慢时如何查找问题</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>当一个Java程序频繁FullGC时如何解决问题，如何查看垃圾回收日志</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>当一个Java应用发生OutOfMemory时该如何解决，年轻代、年老代、永久代解决办法不同，导致原因也不同</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>怎样诊断高CPU的应用</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>CAP只知道概念，什么是分区容忍答不上来</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>分布式系统高可用和扩展</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>jvm gc</strong></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>分布式事务 二阶段提交</strong>


<br /></label></li>
</ul>

<h3 id="开放思维">开放思维</h3>

<ul class="task-list">
<li><strong>文章</strong></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="https://segmentfault.com/a/1190000016172470" rel="nofollow noreferrer" target="_blank">https://segmentfault.com/a/1190000016172470</a></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="https://blog.csdn.net/sinat_35512245/article/details/60325685" rel="nofollow noreferrer" target="_blank">https://blog.csdn.net/sinat_35512245/article/details/60325685</a></label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> <a href="https://zhuanlan.zhihu.com/p/33273041" rel="nofollow noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/33273041</a></label></li>

<li><p>[ ] <a href="https://segmentfault.com/a/1190000016985310" rel="nofollow noreferrer" target="_blank">https://segmentfault.com/a/1190000016985310</a></p></li>

<li><p>[ ] <strong>设计一个生产者（文件读）消费者（把文件数据写到网络）模型，使用 wait、notify或其他方法实现</strong></p></li>

<li><p>[ ] <strong>日志查找关键字</strong></p></li>

<li><p>[ ] <strong>责任链，排序</strong></p></li>

<li><p>[ ] <strong>给出n个节点，标号分别从0到 n-1 并且给出一个无向边的列表 (给出每条边的两个顶点), 写一个函数去判断这张无向图是否是一棵树，假设我们不会给出重复的边在边的列表当中. 无向边 [0, 1] 和 [1, 0] 是同一条边， 因此他们不会同时出现在我们给你的边的列表当中。</strong>样例：</p></li>
</ul>

<pre><code class="language-text">          1) 给出n = 5 并且 edges = [0, 1], [0, 2], [0, 3], [1, 4], 返回 true.
          2) 给出n = 5 并且 edges = [0, 1], [1, 2], [2, 3], [1, 3], [1, 4], 返回 false.
</code></pre></li>
</ul></li>

<li><p>[ ] <strong>一个有序数组，实现一个查找函数，找出指定元素在数组中第一次出现的位置，要求：时间复杂度最优；</strong></p></li>

<li><p>[ ] <strong>如何创建线程</strong></p>

<ul>
<li>第一种方法：继承Thread类，重写run()方法，run()方法代表线程要执行的任务。</li>
<li>第二种方法：实现Runnable接口，重写run()方法，run()方法代表线程要执行的任务。</li>
<li>第三种方法：实现callable接口，重写call()方法，call()作为线程的执行体，具有返回值，并且可以对异常进行声明和抛出</li>
</ul></li>
</ul>

<p>使用start()方法来启动线程
优点：因为JAVA是单继承机制，当我们继承Thread类后就不能继承其他类了，所以选用实现Runnable接口。
  - 1.通过实现Runnable接口来创建Thread线程：</p>

<pre><code class="language-text">步骤1：创建实现Runnable接口的类：   
Java代码 
  class SomeRunnable implements Runnable   { 
  public void run()   { 
  //do something here   }  
} 
  步骤2：创建一个类对象： 
  Runnable oneRunnable = new SomeRunnable();   
步骤3：由Runnable创建一个Thread对象：   
Thread oneThread = new Thread(oneRunnable);   
步骤4：启动线程：   
oneThread.start(); 
  至此，一个线程就创建完成了。 
  当调用完oneRunnable对象中的void run();方法后，线程就消亡了。
</code></pre>

<ul>
<li>2.通过继承Thread类来创建一个线程：<br /></li>
</ul>

<pre><code class="language-text">步骤1：定义一个继承Thread类的子类：   
Java代码 
  class SomeThead extends Thraad   { 
  public void run()   { 
  //do something here   }   } 
  步骤2：构造子类的一个对象： 
 SomeThread oneThread = new SomeThread();   
  步骤3：启动线程：   
 oneThread.start(); 
  至此，一个线程就创建完成了。
</code></pre>

<ul>
<li>3.通过Callable和Future创建线程</li>
</ul>

<pre><code class="language-text">（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。
（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。
（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。
（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值其中，Callable接口(也只有一个方法)定义如下：  
  Java代码 
  public interface Callable   { 
  V call() throws Exception;   } 
  步骤1：创建实现Callable接口的类SomeCallable(略);   
  步骤2：创建一个类对象： 
      Callable oneCallable = new SomeCallable(); 
  步骤3：由Callable创建一个FutureTask对象：   
    FutureTask oneTask = new FutureTask(oneCallable); 
  注释： FutureTask是一个包装器，它通过接受Callable来创建，它同时实现了 Future和Runnable接口。 
  步骤4：由FutureTask创建一个Thread对象：   
    Thread oneThread = new Thread(oneTask);   
  步骤5：启动线程：  
    oneThread.start(); 
  至此，一个线程就创建完成了。
</code></pre>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>每个单词是以26个大写或小写英文字母构成，可能含有非法字符，非构成单词的字符均视为单词间隔符，要求倒排后的单词间隔符以一个空格表示；如果原字符串中相邻单词间有多个间隔符时，倒排转换后也只允许出现一个空格间隔符，不用写main函数，只写字符串处理函数就可以；不用IDE，直接在网页上编写。</strong></label></li>
</ul>

<p>比如：
【输入】I am @!#$software1234engineer1234
【输出】engineer software am I**</p>

<pre><code class="language-java">String input = &quot;I am @!#$software1234engineer1234&quot;;
String replacedStr = input.replaceAll(&quot;[^a-zA-Z]&quot;,&quot; &quot;);

String [] splitedStr = replacedStr.split(&quot; &quot;);

Stack&lt;String&gt; stack = new Stack();
for (int i=0;i&lt;splitedStr.length;i++){
	  String str = splitedStr[i];
 if (!&quot; &quot;.equals(str)){
   stack.push(str);
 }
}

StringBuilder output = new StringBuilder();
for (int j=0;j&lt;stack.size();j++){
  output.append(stack.pop());
}
System.out.println(output.toString());
  
</code></pre>

<h3 id="扩展视野">扩展视野</h3>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> gRPC</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> fork/join</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> 并发和并行</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> lambda表达式</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> 异步

<ul>
<li>nio、netty</li>
<li>akka</li>
<li>reactor</li>
</ul></label></li>
</ul>

<h3 id="中间件">中间件</h3>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> memcache和redis的区别</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> redis能存哪些类型</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> dubbo</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> kafka</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> zk</label></li>
</ul>

    </div>
</div>

          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2010 - 2019</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="http://ftex.github.io/">j.c</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
    
    <script src="/js/vendor_no_gallery.min.js" async=""></script>
    
  



     </div>
  </body>
</html>
